---
title: Release의 모든 것
date: 2025-12-01 09:00:00 +0900
categories: architecture
tags:
  - architecture
  - book
description:
---

 이 책은 개발자에게 현실에서 잘 작동하는 프로그램을 만드는 방법을 알려준다. 또한 해결할 문제가 무엇이고 어떻게 그 문제를 해결할 수 있는지 설명한다. 책에서 가장 중요한 개념 하나를 고르면 운영 고려 설계라고 할 수 있다.

<br/>

## 안정성 구축
---

### 1. 운영 환경의 현실
---

계획을 아무리 철저하게 세우더라도 안 좋은 일이 생긴다는 사실을 받아들여야 한다. 할 수 있는 만큼의 조치를 취하고 예방하면서, 정말 심각하고 예상치 못한 피해가 발생하더라도 전체 시스템이 복구될 수 있게 만들어야 한다.

<br/>

#### 1.1. 올바른 목표 설정
---

이 책에서는 적은 비용으로 고품질의 제품을 생산할 수 있도록 설계하는 공학적 접근법인 제조 고려 설계와 유사한 **운영 고려 설계**라는 개념을 내세운다.

<br/>

#### 1.2. 도전의 범위
---

오늘날엔 활성 사용자가 매우 많으면서 고가용성의 시스템에 대한 요구가 증가하고 있다.

<br/>

#### 1.3. 여기도 백만 달러, 저기도 백만 달러
---

설계와 아키텍처 결정은 재무적인 결정이기도 하다. 따라서 구현 비용뿐만 아니라 파생 비용까지 고려해서 결정해야 한다.

<br/>

#### 1.4. '포스'를 사용하라
---

초기에 내리는 결정은 시스템의 최종 모습에 가장 큰 영향을 미친다. 각 의사 결정이 가용성, 처리량, 유연성에 미치는 영향을 고려하는 것이 중요하다.

<br/>

#### 1.5. 실용주의 아키텍처
---

실용주의 아키텍트는 메모리 사용량, CPU 소모량, 대역폭 요구량, 하이퍼스레딩과 CPU 바인딩의 장단점 같은 문제에 관해 논의할 가능성이 높다.

<br/>

## 2. 사례 연구: 항공사를 멈추게 한 예외
---

CF(Core Facility, 핵심 지원) 기능을 제공하는 데이터베이스 클러스터가 계획된 대체 시스템 전환 과정을 시작했다. CF 시스템은 고가용성 시스템으로 구축됐다.

이 시스템은 애플리케이션 서버의 클러스터에서 작동했으며 여분의 복구용 데이터베이스를 가지고 있었다. 모든 데이터는 외장 디스크에 저장되었고, 하루에 두 번 원격지 백업이 이루어졌으며, 별도의 위치에 있는 디스크로 늦어도 5분 이내에 데이터가 복제되는 것이 보장됐다.

앞단에서는 한 쌍의 하드웨어 부하 분산기가 들어오는 트래픽을 애플리케이션 서버 중 한 대로 전달해주었다.

랙 하나가 손상되거나 망가질 때를 대비해 서버들을 여러 다른 랙으로 분할까지 했다.

<br/>

### 2.1. 변경 시간대
---

1분 안에 베리타스는 데이터베이스 1에 있는 오라클 서버를 내리고, RAID 어레이에서 파일 시스템을 마운트 해제하고, 데이터베이스 2에서 이것을 다시 마운트하고, 이 곳의 오라클 서버를 실행시킨 후, 가상 IP 주소를 데이터베이스 2에 재할당한다.

<br/>

### 2.2. 작동 중단
---

어떤 경우라도 서비스 복원이 최우선이다. 작동 중단 시간을 더 늘리지 않고 사후 분석을 위한 약간의 데이터를 수집할 수 있다면 더 좋다.

우선적으로 문제가 있는 서버들을 재시작하여 문제를 해결했다.

<br/>

### 2.4. 사후 분석
---

사후 조사를 수행하고 몇 가지 질문에 대한 답을 찾아야 한다.
1. 예비 데이터베이스 교체 작업이 장애를 유발했는가? 아니라면 무엇이 원인인가?
2. 클러스터 구성에는 문제가 없었나?
3. 운영 팀은 유지 보수를 올바르게 수행했나?
4. 어떻게 서비스가 중단되기 전에 장애를 감지할 수 있었나?
5. 이런 일이 다시는 일어나지 않도록 할 방법은 무엇인가?

<br/>

### 2.5. 단서 수색
---

클러스터에 생기는 일반적인 문제가 있는지 찾아봤다.

1. 클러스터 내의 노드가 정상 작동 중임을 확인하는 신호가 충분한가?
2. 정상 작동 확인 작업이 서비스 트래픽을 처리하는 스위치를 통해 이루어졌는가?
3. 서버가 가상 IP 주소가 아닌 물리 주소를 사용하도록 설정되었나?
4. 잘못된 패키지가 설치되었나?

<br/>

다음은 애플리케이션 서버의 구성을 살펴볼 차례였다. 필자는 작동이 멈춘 애플리케이션을 디버깅할 때 자바 스레드 덤프를 애용한다. 스레드 덤프로 다음 내용들을 추론할 수 있다.

1. 애플리케이션이 사용하는 외부 라이브러리
2. 사용하는 스레드 풀의 유형
3. 스레드 풀마다 가지고 있는 스레드 수
4. 애플리케이션이 뒷단에서 수해아는 작업
5. 애플리케이션이 사용하는 프로토콜 (각 스레드의 스택 추적 정보에서 클래스와 메서드를 살펴봄으로써 확인 가능)

<br/>

**스레드 덤프 획득**

JVM에 직접 연결하는 것이 허용된다면 `jcmd` 를 사용해서 JVM을 실행시킨 터미널이 아니더라도 JVM의 스레드 덤프를 받을 수 있다.

```
jcmd 18835 Thread.print
```

<br/>

직접 연결할 수 있다면 `jconsole` 이 대상 JVM을 가리키도록 하고 GUI로 스레드를 살펴볼 수 있다.

<br/>

스레드 덤프를 통해 스레드의 실행 상태를 확인할 수 있고 스레드 풀로 관리되고 있는지를 알 수 있다.

---

<br/>

스레드 덤프 확인을 통해 CF 시스템 내에 문제가 있다는 것을 알 수 있었다. 외부 요청에 할당된 40개의 스레드 전체가 자바 소켓 라이브러리 내부의 네이티브 메서드인 `SocketInputStream.socketRead0()` 안에서 블록되어 있었다. 모든 스레드는 절대 오지 않을 응답을 읽기 위해 헛된 노력을 기울이고 있었다.

<br/>

스레드 덤프를 확인해보니 40개의 스레드가 `FilghtSearch.lookupByCity()` 를 실행하고 있는 것을 알 수 있었다. 이는 RMI(Remote method invocation, 원격 함수 호출)와 EJB(Enterprise JavaBeans) 메서드를 참조하고 있었다. 

<br/>

RMI는 서로 다른 컴퓨터 간의 통신을 내부 코드를 호출하는 것처럼 만들어준다. 모든 내부 호출이 그렇듯 RMI 호출은 응답을 무한정 기다리기 때문에 위험한 상황이 발생할 수 있다. 결국 호출한 측은 원격 서버의 문제에 취약하다.

<br/>

### 2.6. 결정적 단서
---

CF 애플리케이션 서버는 별도의 스레드 풀을 사용해서 EJB 호출과 HTTP 요청을 처리했다. 이 때문에 CF 서비스에 장애가 발생했음에도 모니터링 애플리케이션에 응답할 수 있었다. 사실 모든 애플리케이션 서버의 모든 스레드는 하나 같이 정확히 동일한 코드에서 블록되었다. 바로 자원 풀에서 데이터베이스 연결을 확인하려는 코드였다.

<br/>

소스 코드에 접근할 방법이 없었기 때문에 운영에서 이진 코드를 가지고 와서 역컴파일했다. 

```java
package com.example.cf.flightsearch;
// ...
public class FlightSearch implements SessionBean {
  private MonitoredDataSource connectionPool;
  public List lookupByCify(...) throws SQLException, RemoteException {
	  Connection conn = null;
	  Statement stmt = null;
	  try {
	    conn = connectionPool.getConnection();
	    stmt = conn.createStatement();
	    // 조회 로직 수행
	    // 결과 리스트 반환
	  } finally {
	    if (stmt != null) {
	      stmt.close();
	    }
	    if (conn != null) {
	      conn.close();
	    }
	  }
  }
}
```

<br/>

`jaav.sql.Statement.close()` 는 `SQLException` 을 던질 수 있다. 오라클 드라이버는 연결을 닫으려는 `IOException` 을 만날 때 이렇게 작동한다. 예를 들어 데이터베이스 서버를 대체 서버로 교체했을 때 말이다. 

<br/>

앞서 살펴본 코드에서 `Statement` 를 닫을 때 예외가 발생하면 연결이 닫히지 않아서 결국 자원 누수가 발생한다. 이런 호출이 40번 발생하면 자원 풀은 고갈되고 향후 모든 호출은 `connectionPool.getConnection()` 에서 블록될 것이다. 이것이 바로 CF의 스레드 덤프에서 본 것이다.

<br/>

### 2.7. 외양간 고치기?
---




<br/>

## Reference
---

[Release의 모든 것](https://product.kyobobook.co.kr/detail/S000211502257)