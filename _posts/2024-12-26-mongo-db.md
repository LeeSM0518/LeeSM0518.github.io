---
title: MongoDB
date: 2024-12-26 09:00:00 +0900
categories: mongodb
tags:
  - mongodb
  - database
description: MongoDB 학습 및 정리
---

## 1. 몽고DB 시작
---

몽고DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스다. 보조 인덱스(secondary index), 범위 쿼리(range query), 정렬(sorting), 집계(aggregation), 공간 정보 인덱스(geospatial index) 등을 확장 기능과 결합했다.

<br/>

### 1.1. 손쉬운 사용
---

몽고DB는 관계형 데이터베이스가 아니라 **도큐먼트 지향** 데이터베이스다. 관계형 모델을 사용하지 않는 주된 이유는 **분산 확장(scale-out)**을 쉽게 하기 위함이지만 다른 이점도 있다.

도큐먼트 지향 데이터베이스에서는 도큐먼트를 사용하여 복잡한 계층 관계를 하나의 레코드로 표현할 수 있다. 이는 객체 지향 언어 관점에 매우 적합하다.

또한 몽고DB에서는 도큐먼트의 **키와 값을 미리 정의하지 않는다.** 따라서 고정된 스키마가 없으므로 쉽게 필드를 추가하거나 제거할 수 있다.

<br/>

### 1.2. 확장 가능한 설계
---

**분산 확장**은 저장 공간을 늘리거나 처리량을 높이고 서버를 구매해서 클러스터에 추가하는 방법이다. 따라서 경제적이고 확장이 용이하다. 하지만 하나의 장비만 관리할 때보다 관리가 어렵다.

몽고DB는 분산 확장을 염두에 두고 설계됐다. **도큐먼트를 자동으로 재분배**하고 사용자 **요청을 올바르게 장비에 라우팅**함으로써 클러스터 내 **데이터 양과 부하를 조절**할 수 있다.

<br/>

### 1.3. 다양한 기능
---

인덱싱
: 일반적인 보조 인덱스를 지원하며 고유(unique), 복합(compound), 공간 정보, 전문(full-text) 인덱싱 기능도 제공한다. 중첩된 도큐먼트(nested document) 및 배열과 같은 계층 구조의 보조 인덱스도 지원한다.

집계
: 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공한다. 

특수한 컬렉션 유형
: 최신 데이터를 유지하고자 세션이나 고정 크기 컬렉션과 같이 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(TTL, Time-To-Live) 컬렉션을 지원한다. 또한 기준 필터(criteria filter)와 일치하는 도큐먼트에 한정된 부분 인덱스를 지원함으로써 효율성을 높이고 필요한 저장 공간을 줄인다.

파일 스토리지
: 큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원한다.

<br/>

몽고DB는 3.2에 도입된 `$lookup` 집계 연산자를 사용하면 **매우 제한된 방식으로 조인하는 것이 가능**하다. 3.6 버전에서는 관련 없는 서브쿼리 뿐만 아니라 **여러 조인 조건으로 보다 복잡한 조인도 할 수 있다.**

<br/>

### 1.4. 고성능
---

몽고DB에서는 동시성(concurrency)과 처리량을 극대화하기 위해 **와이어드타이거(WiredTiger) 스토리지 엔진에 기회적 락(oppertunistic locking)** 을 사용했다. 따라서 캐시처럼 제한된 용량의 램으로 쿼리에 알맞은 **인덱스를 자동으로 선택** 할 수 있다.

<br/>

### 1.5. 몽고DB의 철학
---

몽고DB 프로젝트의 주 관심사는 확장성이 높으며 유연하고 빠른 데이터 스토리지를 만드는 것이다.

<br/>

## 2. 몽고DB 기본
---

- 몽고DB 데이터의 기본 단위는 **도큐먼트** 이며, RDB의 행과 유사하다.
- **컬렉션** 은 동적 스키마가 있는 테이블과 같다.
- 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 **데이터베이스** 를 호스팅한다.
- 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 `"_id"` 를 갖는다.
- 몽고DB는 **몽고 쉘** 이라는 도구와 함께 배포된다. 몽고 셸은 인스턴스를 관리하고 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공한다. 또한 사용자가 자신의 스크립트를 만들고 로드할 수 있다.

<br/>

### 2.1. 도큐먼트
---

몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이뤄진 **도큐먼트**다.

<br/>

```json
{"greeting" : "Hello, world!"}
```

대부분의 도큐먼트는 이보다 복잡한 다중 키/값 쌍을 가진다.

<br/>

도큐먼트의 키는 문자열이다. 다음 예외 몇 가지를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.
- 키는 `\0(null 문자)` 을 포함하지 않는다. `\0` 은 키의 끝을 나타내는 데 사용된다.
- `.` 과 `$` 문자들은 예약어이며 부적절하게 사용하면 경고가 발생한다.

<br/>

몽고DB는 데이터형과 대소문자를 구별한다. 또한, 키가 중복될 수 없다.

<br/>

### 2.2. 컬렉션
---

**컬렉션**은 도큐먼트의 모음이다. RDB의 테이블에 대응된다고 볼 수 있다.

<br/>

#### 2.2.1. 동적 스키마
---

컬렉션은 **동적 스키마**를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다는 의미다. 예를 들어 다음 도큐먼트들을 하나의 컬렉션에 저장할 수 있다.

```json
{"greeting" : "Hello, world!", "views": 3}
{"signoff" : "Good night, and good luck"}
```

<br/>

도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다르다. 도큐먼트에 별도의 스키마가 필요 없지만 **하나 이상의 컬렉션이 필요한 이유**는 다음과 같다.
- 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 **번거로운 일이 생길 수도** 있다.
- 컬렉션별로 목록을 뽑으면 한 컬렉션 내 특정 데이터형별로 쿼리해서 목록을 뽑을 때보다 **훨씬 빠르다.**
- 같은 종류의 데이터를 하나의 컬렉션에 모아두면 **데이터 지역성**에도 좋다.
- **인덱스**를 만들면 도큐먼트는 특정 구조를 가져야 한다.

<br/>

애플리케이션 스키마는 기본적으로 필요하지는 않지만 정의하면 좋다. 몽고DB의 도큐먼트 유효성 검사 기능(document validation functionality)과 객체-도큐먼트 매핑 라이브러리(object-document mapping library)를 이용하여 사용 가능하다.

<br/>

#### 2.2.2. 네이밍
---

컬렉션은 이름으로 식별된다. 이는 몇 가지 제약 조건이 있다.
- 빈 문자열("")은 유효한 이름이 아니다.
- `\0(null 문자)` 은 컬렉션명의 끝을 나타내는 문자이므로 사용할 수 없다.
- `system.` 으로 시작하는 컬렉션명은 예약어이므로 사용할 수 없다.
- 사용자가 만든 컬렉션은 이름에 예약어인 `$` 를 포함할 수 없다.

<br/>

##### 서브컬렉션

서브컬렉션의 네임스페이스에 `.(마침표)` 문자를 사용해 컬렉션을 체계화한다. (ex. `blog.posts` 와 `blog.authors` ) 

서브컬렉션은 특별한 속성은 없지만 여러 몽고DB 툴에서 지원하므로 유용하다.
- 큰 파일을 저장하는 프로토콜인 **GridFS**는 콘텐츠 데이터와 별도로 **메타데이터를 저장하는 데 서브 컬렉션을 사용**한다.
- 대부분의 드라이버는 특정 컬렉션의 서브컬렉션에 접근하는 몇 가지 **편리한 문법을 제공한다.**

<br/>

### 2.3. 데이터베이스
---

몽고DB는 컬렉션에 **도큐먼트를 그룹화**할 뿐 아니라 데이터베이스에 **컬렉션을 그룹 지어 놓는다.** 몽고DB의 단일 **인스턴스**는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적으로 취급할 수 있다.

데이터베이스는 컬렉션과 마찬가지로 **이름으로 식별**된다. 이는 몇 가지 제약 조건이 있다.
- 빈 문자열("")은 유효한 이름이 아니다.
- `/` , `\` , `.` , `' '` , `*` , `<` , `>` , `:` , `|` , `?` , `$` , `\0` 문자들을 포함할 수 없다.
- 대소문자를 구별한다.
- 최대 64바이트다.

<br/>

직접 접근할 수는 있지만 특별한 의미를 갖는 **예약된 데이터베이스 이름**도 있다.

admin
: 인증과 권한 부여 역할을 한다.

local
: 단일 서버에 대한 데이터를 저장한다.

config
: 각 샤드의 정보를 저장한다.

<br/>

컬렉션을 저장하는 데이터베이스의 이름을 컬렉션명 앞에 붙이면 네임스페이스를 얻는다. 예를 들어 cms 데이터베이스의 blog.posts 컬렉션을 사용한다면 컬렉션의 네임스페이스는 cms.blog.posts가 된다.

<br/>

### 2.4. 몽고DB 시작
---

docker-compose를 활용하여 몽고DB를 실행하는 과정이다.

1. `data` 폴더 생성
	```sh
	$ mkdir data
	```
2. `docker-compose.yml` 파일 생성
	```yaml
	version: "3.8"
	services:
	    mongodb:
	        image: mongo
	        container_name: mongodb
	        ports:
	            - 27017:27017
	        volumes:
	            - ./data:/data/db
	        environment:
	            - MONGO_INITDB_ROOT_USERNAME=root
	            - MONGO_INITDB_ROOT_PASSWORD=root
	    mongo-express:
	        image: mongo-express
	        container_name: mongo-express
	        restart: always
	        ports:
	            - 8081:8081
	        environment:
	            - ME_CONFIG_MONGODB_ADMINUSERNAME=root
	            - ME_CONFIG_MONGODB_ADMINPASSWORD=root
	            - ME_CONFIG_MONGODB_SERVER=mongodb
	```
3. docker-compose 실행
	```sh
	$ docker-compose up -d && docker-compose logs -f
	```
4. `localhost:8081` 로 접속한 후에 로그인
	- id : `admin`
	- pw : `pass`
5. 셸로 접속
	```sh
	$ docker exec -it mongodb /bin/bash
	# 컨테이너로 접속 후
	$ mongosh
	```

<br/>

### 2.5. 몽고DB 셸 소개
---

셸은 관리 기능이나, 실행 중인 **인스턴스를 점검하거나 간단한 기능을 시험**하는 데 매우 유용하다.

<br/>

#### 2.5.1. 셸 실행
---

mongosh을 통해 셸을 시작한다.

```sh
$ mongosh
Current Mongosh Log ID:	676e45c5d74e662877fc0420
Connecting to:		mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.3.4
Using MongoDB:		8.0.4
Using Mongosh:		2.3.4

For mongosh info see: https://www.mongodb.com/docs/mongodb-shell/


To help improve our products, anonymous usage data is collected and sent to MongoDB periodically (https://www.mongodb.com/legal/privacy-policy).
You can opt-out by running the disableTelemetry() command.

test>
```

<br/>

셸은 완전한 자바스크립트 해석기이며 임의의 자바스크립트 프로그램을 실행한다.

```sh
test> x = 200;
200
test> x / 5;
40
```

<br/>

또한 표준 **자바스크립트 라이브러리의 모든 기능을 활용할 수 있다.**

```sh
test> Math.sin(Math.PI / 2)
1
test> new Date("2019/1/1");
ISODate('2019-01-01T00:00:00.000Z')
test> "Hello, world!".replace("World", "MongoDB");
Hello, world!
```

<br/>

심지어 자바스크립트 **함수를 정의하고 호출**할 수도 있다.

```sh
test> function factorial(n) {
... if (n <= 1) return 1;
... return n * factorial(n - 1);
... }
[Function: factorial]
test> factorial(5);
120
```

<br/>

#### 2.5.2. 몽고DB 클라이언트
---

셸은 시작할 때 몽고DB 서버의 `test` 데이터베이스에 연결하고, 데이터베이스 연결을 전역 변수 `db` 에 할당한다. 셸에서는 주로 이 변수를 통해 몽고DB에 접근한다.

<br/>

현재 db에 할당된 데이터베이스를 확인하려면 `db` 를 입력한다.

```sh
test> db
test
```

<br/>

데이터베이스 선택을 살펴보자.

```sh
test> use video
switched to db video
video>
```
- 이와 같이 db 변수는 video 데이터베이스를 가리킨다.

<br/>

자바스크립트 셸이므로 변수 이름을 입력하면 표현식으로 평가된다. 그런 다음 값이 출력된다. 다음과 같이 db 변수에서 컬렉션에 접근한다.

```sh
video> db.movies
video.movies
```
- 현재 데이터베이스의 movies 컬렉션을 반환한다.

<br/>

#### 2.5.3. 셸 기본 작업
---

셸에서 CRUD 작업을 할 수 있다.

<br/>

##### 인증

```sh
db> use admin
switched to db admin
admin> db.auth('root','root')
{ ok: 1 }
admin> show users
[
  {
    _id: 'admin.root',
    userId: UUID('9a65918d-12f8-471c-b59b-51815739c9e7'),
    user: 'root',
    db: 'admin',
    roles: [ { role: 'root', db: 'admin' } ],
    mechanisms: [ 'SCRAM-SHA-1', 'SCRAM-SHA-256' ]
  }
]
```

<br/>

##### 생성

`insertOne` 함수는 컬렉션에 도큐먼트를 추가한다. 우선 도큐먼트를 나타내는 자바스크립트 객체인 movie라는 지역 변수를 생성한다.

```sh
video> movie = {"title" : "Star Wars: Episode IV - A New Hope",
... "director" : "George Lucas",
... "year" : 1977}
{
  title: 'Star Wars: Episode IV - A New Hope',
  director: 'George Lucas',
  year: 1977
}
```

<br/>

`insertOne` 함수를 이용해 movies 컬렉션에 저장할 수 있다.

```sh
admin> db.movies.insertOne(movie)
{
  acknowledged: true,
  insertedId: ObjectId('676e4a4046b45663fdfc0422')
}
```
- 다음과 같은 인증 에러가 발생하여 인증을 수행한 후에 movie를 저장했다.
	```sh
	MongoServerError[Unauthorized]: Command insert requires authentication
	```

<br/>

컬렉션에 `find` 를 호출해서 확인하자.

```sh
admin> db.movies.find().pretty()
[
  {
    _id: ObjectId('676e4a4046b45663fdfc0422'),
    title: 'Star Wars: Episode IV - A New Hope',
    director: 'George Lucas',
    year: 1977
  }
]
```
- `_id` 키가 추가됐고 다른 키/값 쌍들은 입력한 대로 저장됐다.

<br/>

##### 읽기

`find` 와 `findOne` 은 컬렉션을 쿼리하는 데 사용한다. 단일 도큐먼트를 읽으려면 `findOne` 을 사용하면 된다.

```sh
admin> db.movies.findOne()
{
  _id: ObjectId('676e4a4046b45663fdfc0422'),
  title: 'Star Wars: Episode IV - A New Hope',
  director: 'George Lucas',
  year: 1977
}
```
- `find` 와 `findOne` 은 **쿼리 도큐먼트** 형태로 조건 전달도 가능하다. 

<br/>

##### 갱신

데이터를 갱신하려면 `updateOne` 을 사용한다. `updateOne` 의 매개변수는 최소 두 개다. 첫 번째는 **수정할 도큐먼트를 찾는 기준**이고, 두 번째는 **갱신 작업**을 설명하는 도큐먼트이다. 갱신하려면 갱신 연산자인 `set` 을 이용하면 된다.

```sh
admin> db.movies.updateOne({title: "Star Wars: Episode IV - A New Hope"},
... {$set : {reviews: []}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.movies.find().pretty()
[
  {
    _id: ObjectId('676e4a4046b45663fdfc0422'),
    title: 'Star Wars: Episode IV - A New Hope',
    director: 'George Lucas',
    year: 1977,
    reviews: []
  }
]
```
- `review` 키가 생긴 것을 확인할 수 있다.

<br/>

##### 삭제

`deleteOne` 과 `deleteMany` 는 도큐먼트를 데이터베이스에서 영구적으로 삭제한다. 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정한다.

```sh
admin> db.movies.deleteOne({title : "Star Wars: Episode IV - A New Hope"})
{ acknowledged: true, deletedCount: 1 }
admin> db.movies.find().pretty()

```
- 필터와 일치하는 모든 도큐먼트를 삭제하려면 `deleteMany` 를 사용한다.

<br/>

### 2.6. 데이터형
---

몽고DB는 도큐먼트의 값으로 다양한 데이터형을 지원한다.

<br/>

#### 2.6.1. 기본 데이터형
---

몽고DB에서 도큐먼트는 JSON과 닮았다고 생각할 수 있다. 이는 여섯 가지 데이터형만을 열거하다. 데이터형이 null, 불리언, 숫자, 문자열, 배열, 객체만 지원하기 때문에 표현력은 제한적이다.

JSON은 날짜형이 없어 날짜를 다루기가 까다롭다. 부동소수점형과 정수형을 표현하는 방법이 없고, 32비트와 64비트도 구별되지 않는다.

몽고DB는 JSON의 키/값 쌍 성질을 유지하면서 추가적인 데이터형을 지원한다. 가장 일반적인 데이터형은 다음과 같다.

<br/>

null
: null 값과 존재하지 않는 필드를 표현하는 데 사용한다.

불리언
: 참과 거짓 값에 사용한다.

숫자
: 셸은 64비트 부동소수점 수를 기본으로 사용한다. 4바이트 혹은 8바이트의 부호 정수는 각각 `NumberInt` 혹은 `NumberLong` 클래스를 사용한다.

문자열
: 어떤 UTF-8 문자열이든 표현할 수 있다.

날짜
: 몽고DB는 1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장한다.

정규표현식
: 쿼리는 자바스크립트의 정규 표현식 문법을 사용할 수 있다.

배열
: 값의 셋이나 리스트를 배열로 표현할 수 있다.

내장 도큐먼트
: 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다.

객체 ID
: 객체 ID는 도큐먼트용 12바이트 ID다. (ex `ObjectId()`)

<br/>

다음은 상대적으로 덜 사용되는 데이터형 목록이다.

이진 데이터
: 임의의 바이트 문자열이며 셸에서는 조작이 불가능하다.

코드
: 쿼리와 도큐먼트는 임의의 자바스크립트 코드를 포함할 수 있다. (ex. `function () { /* ... */ }`)

<br/>

#### 2.6.2. 날짜
---

자바스크립트에서 Date 클래스는 몽고DB의 날짜를 표현하는 데 사용한다. 새로운 Date 객체를 생성할 때는 `new Date()` 를 호출해야 한다. 셸에서는 날짜가 현지 시간대 설정을 이용해 표시되며, 표준 시간대 정보는 없다.

<br/>

#### 2.6.3. 배열
---

배열은 **정렬 연산(리스트, 스택, 큐)**과 **비정렬 연산(셋)**에 호환성 있게 사용 가능한 값이다.

```sh
{"thighs" : ["pie", 3.14]}
```
- 서로 다른 데이터형을 값으로 포함할 수 있다. 
- 심지어는 중첩 배열도 될 수 있다.

<br/>

도큐먼트 내 배열의 장점으로 몽고DB가 **배열의 구조를 '이해한다'**는 점과, 배열의 내용에 작업을 수행하기 위해 **내부에 도달하는 방법을 안다**는 점이 있다. 따라서 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다.

<br/>

#### 2.6.4. 내장 도큐먼트
---

도큐먼트는 키에 대한 값이 될 수 있는데 이를 **내장 도큐먼트**라고 한다.

```json
{
	"name" : "John Doe",
	"address" : {
		"street" : "123 Park Street",
		"city" : "Anytown",
		"state" : "NY"
	}
}
```
- address는 내장 도큐먼트이다.
- 이러한 특성으로 몽고DB는 데이터 반복이 생길 수 있다는 단점이 있다.

<br/>

#### 2.6.5. _id와 ObjectId
---

몽고DB에 저장된 모든 도큐먼트는 `_id` 키를 가진다. `_id` 키 값은 어떤 데이터형이어도 상관없지만 `ObjectId` 가 기본이다. 하나의 컬렉션에서 모든 도큐먼트는 고유한 `_id` 값을 가지며, 이 값은 컬렉션 내 **모든 도큐먼트가 고유하게 식별되게 한다.**

<br/>

##### ObjectIds

`ObjectId` 는 `_id` 의 기본 데이터형이다. `ObjectId` 클래스는 가벼우면서도, 전역적으로 고유하게 생성하기 쉽게 설계됐다. `ObjectId` 를 사용하는 이유는 몽고DB의 **분산 특성** 때문이다.

`ObjectId` 는 12바이트 스토리지를 사용하며 24자리 16진수 문자열 표현이 가능하다. 바이트당 2자리를 사용한다.`ObjectId` 가 16진수 문자열로 표현되긴 하지만 실제로 문자열은 저장된 데이터의 두 배만큼 길다는 점을 알아두자.

`ObjectId` 의 첫 4바이트는 타임스탬프다. 다음 5바이트는 랜덤 값이다. 최종 3바이트는 서로 다른 시스템에서 충돌하는 `ObjectId` 들을 생성하지 않도록 랜덤 값으로 시작하는 카운터다. `ObjectId` 는 프로세스당 1초에 256^3(1677만7216)개까지 생성된다.

<br/>

##### _id 자동 생성

도큐먼트를 입력할 때 `_id` 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가된다.

<br/>

### 2.7. 몽고DB 셸 사용
---

다른 장비나 포트에 mongod를 연결하려면 셸을 시작할 때 호스트명, 포트, 데이터베이스를 명시해야 한다.

```sh
$ mongosh some-host:30000/myDB
```
- db는 이제 some-host:30000의 myDB 데이터베이스를 참조한다.
- `--nodb` 옵션을 사용하면 어디에도 연결되지 않은 채 셸을 시작할 수 있다.
- 시작한 후 원하는 때에 `new Mongo(호스트명)` 를 실행함으로써 연결할 수 있다.


<br/>

#### 2.7.1. 셸 활용 팁
---

mongo는 자바스크립트 문서를 참조하면 유용하다. 또한 help를 입력하면 셸에 내장된 도움말을 볼 수 있다. 함수의 기능을 알고 싶으면 함수명을 괄호 없이 입력하면 된다.

<br/>

#### 2.7.2. 셸에서 스크립트 실행하기
---

다음과 같이 자바스크립트 파일을 셸로 전달해 실행할 수도 있다.

```sh
$ mongosh test.js
```

<br/>

또한 `load` 함수를 사용해 대화형 셸에서 스크립트를 실행할 수도 있다.

```sh
test> load('test.js')
true
```

<br/>

스크립트에 주어진 포트에서 로컬로 실행되는 데이터베이스에 연결하고 해당 연결에 db를 설정하는 `connectTo` 함수를 정의하여 사용할 수 있다. **자주 하는 작업이나 관리 작업을 자동화하는 데 셸을 사용**한다.

<br/>

#### 2.7.3. `.mongorc.js` 만들기
---

자주 로드되는 스크립트를 `.mongorc.js` 파일에 넣을 수 있다. 

```js
// .mongorc.js

var compliment = ["attractive", "intelligent", "like Batman"];
var index = Math.floor(Math.random()*3);

print("Hello, " + compliment[index] + " today!");
```
- 그러면 셸을 시작할 때마다 다음과 같은 문구가 뜬다.

<br/>

`.mongorc.js` 스크립트로 사용하고 싶은 전역 변수를 설정하고, 긴 별칭을 짧게 만들고, 내장 함수를 재정의한다. `.mongorc.js` 의 일반적인 용법 중 하나는 위험한 명령어를 제거하는 것이다. `dropDatabase` 나 `deleteIndexes` 같은 함수가 아무것도 수행하지 않게 재정의하거나 모두 선언 해제한다.

```js
var no = function() {
	print("Not on my watch.");
}

// 데이터베이스 삭제 방지
db.dropDatabase = DB.prototype.dropDatabase = no;

// 컬렉션 삭제 방지
DBCollection.prototype.drop = no;

// 인덱스 삭제 방지
DBCollection.prototype.dropIndex = no;
```


<br/>

#### 2.7.4. 프롬프트 커스터마이징하기
---

기본 셸 프롬프트는 문자열이나 함수에 `prompt` 변수를 설정해 재정의한다. 

```sh
admin> prompt = function() { return (new Date()) + "> "; };
[Function: prompt]
Fri Dec 27 2024 08:51:16 GMT+0000 (Coordinated Universal Time)>
```

<br/>

일반적으로 프롬프트 함수는 `getLastError` 호출을 포함해야 한다. 그러면 셸의 연결이 끊겼을 때 쓰기에서의 오류를 감지해서 자동으로 다시 연결해준다.

<br/>

#### 2.7.5. 복잡한 변수 수정하기
---

셸에서 다중행 지원은 제한적이며 이전 행들을 편집할 수 없다. 따라서 코드나 객체 블록이 크면 편집기에서 편집하면 좋다. 셸에서 EDITOR 변수를 설정하자.

<br/>

#### 2.7.6. 불편한 컬렉션명
---

예약어로 되어 있는 컬렉션명을 사용한다면 `getCollection` 함수를 사용해야 한다.

```sh
admin> db.version
[Function: version] AsyncFunction {
  apiVersions: [ 0, 0 ],
  returnsPromise: true,
  serverVersions: [ '0.0.0', '999.999.999' ],
  topologies: [ 'ReplSet', 'Sharded', 'LoadBalanced', 'Standalone' ],
  returnType: { type: 'unknown', attributes: {} },
  deprecated: false,
  platforms: [ 'Compass', 'Browser', 'CLI' ],
  isDirectShellCommand: false,
  acceptsRawInput: false,
  shellCommandCompleter: undefined,
  help: [Function (anonymous)] Help
}
admin> db.getCollection("version")
admin.version
```
- 또한 유효하지 않은 문자로 컬렉션명을 만들었을 때도 사용된다.

<br/>

또 다른 방법으로 배열 접근 구문을 사용해 유효하지 않은 속성명을 피할 수 있다. 자바스크립트에서 `x.y` 는 `x['y']` 와 동일하다.

```js
admin> var collections = ["posts", "comments", "authors"];

admin> for (var i in collections) {
... print(db.blog[collections[i]]);
... }
admin.blog.posts
admin.blog.comments
admin.blog.authors
```

<br/>

## 3. 도큐먼트 생성, 갱신, 삭제
---

데이터베이스에서의 기본적인 데이터 입출력을 다룬다.

<br/>

### 3.1. 도큐먼트 삽입
---

**삽입**은 몽고DB에 데이터를 추가하는 기본 방법이다.

```sh
admin> db.movies.insertOne({"title" : "Stand by Me"})
{
  acknowledged: true,
  insertedId: ObjectId('676e6d44501ea8f45afc0421')
}
admin> db.movies.findOne()
{ _id: ObjectId('676e6d44501ea8f45afc0421'), title: 'Stand by Me'
```
- 도큐먼트에 `_id` 키가 추가되고 도큐먼트가 저장된다.

<br/>

#### 3.1.1. insertMany
---

여러 도큐먼트를 컬렉션에 삽입하려면 `insertMany` 로 도큐먼트 배열을 데이터베이스에 전달한다. 도큐먼트를 대량 삽입하므로 훨씬 더 효율적이다.

```sh
admin> db.movies.insertMany([{"title" : "Ghostbusters"}, {"title": "E.T."}]);
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('676e6de3501ea8f45afc0422'),
    '1': ObjectId('676e6de3501ea8f45afc0423')
  }
}
```
- 48MB보다 큰 메시지를 허용하지 않으므로 이보다 클 경우에는 일괄 삽입 여러 개로 분할한다.

<br/>

`insertMany` 를 사용해 대량 삽입할 때 배열 중간에서 오류가 발생하는 경우, 정렬 연산을 선택했는지 혹은 비정렬 연산을 선택했는지에 따라 달라진다. `insertMany` 에 대한 두 번째 매개변수로 옵션 도큐먼트를 지정할 수 있다. 옵션 도큐먼트에 `ordered` 키에 `true` 를 지정한다. `false` 를 지정하면 몽고DB가 성능을 개선하려고 삽입을 재배열할 수 있다. **정렬되지 않은 삽입의 경우 일부 삽입이 오류를 발생시키는지 여부에 관계없이 모든 도큐먼트 삽입을 시도**한다.

<br/>

다음 예에서는 정렬된 삽입이 기본값이므로 처음 두 개의 도큐먼트만 삽입된다.

```sh
admin> db.movies.insertMany([
... {"_id" : 0, "title" : "test1"},
... {"_id" : 1, "title" : "test2"},
... {"_id" : 1, "title" : "test3"},
... {"_id" : 2, "title" : "test4"}])
Uncaught:
MongoBulkWriteError: E11000 duplicate key error collection: admin.movies index: _id_ dup key: { _id: 1 }
Result: BulkWriteResult {
  insertedCount: 2,
  matchedCount: 0,
  modifiedCount: 0,
  deletedCount: 0,
  upsertedCount: 0,
  upsertedIds: {},
  insertedIds: { '0': 0, '1': 1 }
}
Write Errors: [
  WriteError {
    err: {
      index: 2,
      code: 11000,
      errmsg: 'E11000 duplicate key error collection: admin.movies index: _id_ dup key: { _id: 1 }',
      errInfo: undefined,
      op: { _id: 1, title: 'test3' }
    }
  }
]
admin> db.movies.find()
[
  { _id: ObjectId('676e6d44501ea8f45afc0421'), title: 'Stand by Me' },
  { _id: ObjectId('676e6de3501ea8f45afc0422'), title: 'Ghostbusters' },
  { _id: ObjectId('676e6de3501ea8f45afc0423'), title: 'E.T.' },
  { _id: 0, title: 'test1' },
  { _id: 1, title: 'test2' }
```

<br/>

다음과 같이 정렬되지 않은 삽입을 지정하면 배열의 첫 번째, 두 번째, 네 번째 도큐먼트가 삽입된다.

```sh
admin> db.movies.insertMany([ { "_id": 0, "title": "test1" }, { "_id": 1, "title": "test2" }, { "_id": 1, "title": "test3" }, { "_id": 2, "title": "test4" }], {"ordered" : false})
Uncaught:
MongoBulkWriteError: E11000 duplicate key error collection: admin.movies index: _id_ dup key: { _id: 1 }
Result: BulkWriteResult {
  insertedCount: 3,
  matchedCount: 0,
  modifiedCount: 0,
  deletedCount: 0,
  upsertedCount: 0,
  upsertedIds: {},
  insertedIds: { '0': 0, '1': 1, '3': 2 }
}
Write Errors: [
  WriteError {
    err: {
      index: 2,
      code: 11000,
      errmsg: 'E11000 duplicate key error collection: admin.movies index: _id_ dup key: { _id: 1 }',
      errInfo: undefined,
      op: { _id: 1, title: 'test3' }
    }
  }
]
admin> db.movies.find()
[
  { _id: ObjectId('676e6d44501ea8f45afc0421'), title: 'Stand by Me' },
  { _id: ObjectId('676e6de3501ea8f45afc0422'), title: 'Ghostbusters' },
  { _id: ObjectId('676e6de3501ea8f45afc0423'), title: 'E.T.' },
  { _id: 0, title: 'test1' },
  { _id: 1, title: 'test2' },
  { _id: 2, title: 'test4' }
]
```

<br/>

#### 3.1.2. 삽입 유효성 검사
---

몽고DB는 삽입된 데이터에 최소한의 검사를 수행한다. 도큐먼트의 기본 구조를 검사해 `_id` 필드가 존재하지 않으면 새로 추가하고, 모든 도큐먼트는 16MB보다 작아야 하므로 크기를 검사한다. `doc` 라는 도큐먼트의 Binary JSON 크기를 보려면 셸에서 `object.bsonsize(doc)` 를 실행한다.

<br/>

### 3.2. 도큐먼트 삭제
---

`deleteOne` 과 `deleteMany` 를 통해 데이터를 삭제할 수 있다. 두 메서드 모두 필터 도큐먼트를 첫 번째 매개변수로 사용한다.

```sh
admin> db.movies.find()
[
  { _id: ObjectId('676e6d44501ea8f45afc0421'), title: 'Stand by Me' },
  { _id: ObjectId('676e6de3501ea8f45afc0422'), title: 'Ghostbusters' },
  { _id: ObjectId('676e6de3501ea8f45afc0423'), title: 'E.T.' },
  { _id: 0, title: 'test1' },
  { _id: 1, title: 'test2' },
  { _id: 2, title: 'test4' }
]
admin> db.movies.deleteOne({"_id" : 0})
{ acknowledged: true, deletedCount: 1 }
admin> db.movies.find()
[
  { _id: ObjectId('676e6d44501ea8f45afc0421'), title: 'Stand by Me' },
  { _id: ObjectId('676e6de3501ea8f45afc0422'), title: 'Ghostbusters' },
  { _id: ObjectId('676e6de3501ea8f45afc0423'), title: 'E.T.' },
  { _id: 1, title: 'test2' },
  { _id: 2, title: 'test4' }
]
```
- 여러 도큐먼트와 일치할 경우 첫 번째 도큐먼트를 삭제한다.

<br/>

필터와 일치하는 모든 도큐먼트를 삭제하려면 `deleteMany` 를 사용한다.

```sh
# 조건에 맞는 도큐먼트 목록 제거
admin> db.movies.deleteMany({"year" : 1984})
# 모든 도큐먼트 제거
admin> db.movies.deleteMany({})
```

<br/>

#### 3.2.1. drop
---

전체 컬렉션을 삭제하려면 `drop` 을 사용하는 편이 더 빠르다.

```sh
admin> db.movies.drop()
true
```
- 이는 전부 삭제한 후에 빈 컬렉션에 인덱스를 재생성한다.

<br/>

### 3.3. 도큐먼트 갱신
---

도큐먼트를 데이터베이스에 저장한 후에는 `updateOne` , `updateMany` , `replaceOne` 과 같은 갱신 메서드를 사용해 변경한다. `updateOne` 과 `updateMany` 는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설명하는 수정자 도큐먼트를 두 번째 매개변수로 사용한다. `replaceOne` 는 두 번째 매개변수가 필터와 일치하는 도큐먼트를 교체할 도큐먼트로 지정된다. **갱신은 원자적으로 이뤄진다.** 갱신 요청 두 개가 동시에 발생하면 먼저 도착한 요청이 먼저 적용된다.

<br/>

#### 3.3.1. 도큐먼트 치환
---

`replaceOne` 은 도큐먼트를 새로운 것으로 완전히 치환한다. 예를 들어 사용자 도큐먼트를 다음과 같이 변경한다고 가정하자.

```json
{
	"_id" : ObjectId("4b93819219asdsab"),
	"name" : "joe",
	"friends" : 32,
	"enemies" : 2
}
```
- `friends` 와 `enemies` 필드를 `relationships` 라는 서브도큐먼트로 옮겨보자. 

<br/>

셸에서 도큐먼트의 구조를 수정한 후 `replaceOne` 을 사용해 데이터베이스의 버전을 교체한다.

```sh
admin> var joe = db.users.findOne({"name" : "joe"});

admin> joe.relationships = {"friends" : joe.friends, "enemies" : joe.enemies};
{ friends: 32, enemies: 2 }
admin> joe.username = joe.name;
joe
admin> delete joe.friends;
true
admin> delete joe.friends;
true
admin> delete joe.enemies;
true
admin> delete joe.name;
true
admin> db.users.replaceOne({"name" : "joe"}, joe);
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe'
  }
]
```

<br/>

갱신할 경우, 고유한 도큐먼트를 갱신 대상으로 지정하는 것이 좋다.

```sh
admin> db.users.replaceOne({"_id" : ObjectId('676e7528501ea8f45afc0424')}, joe)
```
- `_id` 값이 컬렉션 기본 인덱스의 기초를 형성하므로 필터에 `_id` 를 사용해도 효율적이다.

<br/>

#### 3.3.2. 갱신 연산자
---

부분 갱신에는 **원자적 갱신 연산자**를 사용한다. 갱신 연산자는 **키를 변경, 추가, 제거**하고, 심지어 **배열과 내장 도큐먼트를 조작**하는 복잡한 갱신 연산을 지정하는 데 사용한다.

<br/>

다음과 같은 예시가 있다고 가정하자.

```sh
admin> db.pageviews.insertOne({"url" : "www.example.com", "pageviews" : 52})
{
  acknowledged: true,
  insertedId: ObjectId('676e76cf501ea8f45afc0425')
}
admin> db.pageviews.find()
[
  {
    _id: ObjectId('676e76cf501ea8f45afc0425'),
    url: 'www.example.com',
    pageviews: 52
  }
]
```

<br/>

누군가가 페이지를 방문할 때마다 URL로 페이지를 찾고 `pageviews` 키의 값을 증가시키려면 `$inc` 제한자를 사용한다.

```sh
admin> db.pageviews.updateOne({"url" : "www.example.com"},
... {"$inc" : {"pageviews" : 1}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.pageviews.find()
[
  {
    _id: ObjectId('676e76cf501ea8f45afc0425'),
    url: 'www.example.com',
    pageviews: 53
  }
]
```
- 연산자를 사용할 때 `_id` 값은 변경할 수 없다.

<br/>

##### `$set` 제한자 사용하기

`$set` 은 필드 값을 설정한다. 필드가 존재하지 않으면 새 필드가 생성된다. 이 기능은 스키마를 갱신하거나 사용자 정의 키를 추가할 때 편리하다.

```sh
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe'
  }
]
admin> db.users.updateOne({"username" : "joe"}, {"$set" : {"favorite book" : "War and Peace"}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    'favorite book': 'War and Peace'
  }
]
```

<br/>

`$set` 은 키의 데이터형도 변경할 수 있다.

```sh
admin> db.users.updateOne({ "username": "joe" }, { "$set": { "favorite book": ["Cat's Cradle", "Foundation Trilogy", "Ender's Game"] } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    'favorite book': [ "Cat's Cradle", 'Foundation Trilogy', "Ender's Game" ]
  }
]
```

<br/>

`$unset` 으로 키와 값을 모두 제거할 수도 있다.

```sh
admin> db.users.updateOne({ "username": "joe" }, { "$unset": { "favorite book": 1 } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe'
  }

```

<br/>

`$set` 은 내장 도큐먼트 내부의 데이터를 변경할 때도 사용한다.

```sh
admin> var joe = db.users.findOne({"username" : "joe"});

admin> joe
{
  _id: ObjectId('676e7528501ea8f45afc0424'),
  relationships: { friends: 32, enemies: 2 },
  username: 'joe'
}
admin> joe.author = {"name": "joe"}
{ name: 'joe' }
admin> db.users.replaceOne({"username":"joe"}, joe);
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    author: { name: 'joe' }
  }
]
admin> db.users.updateOne({"username" : "joe"}, {"$set" : { "author.name" : "joe2" } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    author: { name: 'joe2' }
  }
]
```
- 키를 추가, 변경, 삭제할 때는 항상 `$` 제한자를 사용해야 한다.
- 갱신 연산자를 포함하지 않고 값을 수정하려 하면 오류가 발생한다.

<br/>

##### 증가와 감소

`$inc` 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는 데 사용한다.

```sh
admin> db.games.insertOne({"game" : "pinball", "user" : "joe"})
{
  acknowledged: true,
  insertedId: ObjectId('67722441b151887453fc0421')
}
admin> db.games.updateOne({"game" : "pinball", "user" : "joe"},
... {"$inc" : { "score" : 50 }});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.games.find()
[
  {
    _id: ObjectId('67722441b151887453fc0421'),
    game: 'pinball',
    user: 'joe',
    score: 50
  }
]
admin> db.games.updateOne({ "game": "pinball", "user": "joe" }, { "$inc": { "score": 10000 } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.games.find()
[
  {
    _id: ObjectId('67722441b151887453fc0421'),
    game: 'pinball',
    user: 'joe',
    score: 10050
  }
]
```
- `$inc` 는 `int` , `long` , `double` , `decinal` 타입 값에만 사용할 수 있다.
- `null` , 불리언, 문자열과 같은 데이터형의 값에는 사용할 수 없다.

<br/>

##### 배열 연산자

배열을 다루는 데 갱신 연산자를 사용할 수 있다.

<br/>

*요소 추가하기*

`$push` 는 배열이 이미 존재하면 배열 끝에 요소를 추가하고, 존재하지 않으면 새로운 배열을 생성한다.

```sh
admin> db.blogs.posts.insertOne({"title" : "A blog post", "content" : "contents"})
{
  acknowledged: true,
  insertedId: ObjectId('677225b0b151887453fc0422')
}
admin> db.blogs.posts.findOne()
{
  _id: ObjectId('677225b0b151887453fc0422'),
  title: 'A blog post',
  content: 'contents'
}
admin> db.blogs.posts.updateOne({"title" : "A blog post"},
... {"$push" : {"comments" : { "name" : "joe", "email" : "joe@example.com", "content" : "nice posts."}}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blogs.posts.findOne()
{
  _id: ObjectId('677225b0b151887453fc0422'),
  title: 'A blog post',
  content: 'contents',
  comments: [ { name: 'joe', email: 'joe@example.com', content: 'nice posts.' } ]
}
```

<br/>

`$push` 에 `$each` 제한자를 사용하면 작업 한 번으로 값을 여러 개 추가할 수 있다.

```sh
admin> db.blogs.posts.updateOne({"title" : "A blog post"},
... {"$push" : {"reviews" : {"$each" : [ 1.0, 2.0, 3.0] }}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blogs.posts.findOne()
{
  _id: ObjectId('677225b0b151887453fc0422'),
  title: 'A blog post',
  content: 'contents',
  comments: [ { name: 'joe', email: 'joe@example.com', content: 'nice posts.' } ],
  reviews: [ 1, 2, 3 ]
}
```

<br/>

배열을 특정 길이로 늘이려면 `$slice` 를 `$push` 와 결합해 사용한다. 배열이 특정 크기 이상으로 늘어나지 않게 하고 효과적으로 'top N' 목록을 만들 수 있다.

```sh
admin> db.blogs.posts.updateOne({ "title": "A blog post" }, { "$push": { "top10": { "$each": [1.0, 2.0, 3.0], "$slice" : - 1 } } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blogs.posts.findOne()
{
  _id: ObjectId('677225b0b151887453fc0422'),
  title: 'A blog post',
  content: 'contents',
  comments: [ { name: 'joe', email: 'joe@example.com', content: 'nice posts.' } ],
  reviews: [ 1, 2, 3 ],
  top10: [ 3 ]
}
```
- 요소의 개수를 1개로 제한한다.
- 따라서 `$slice` 는 도큐먼트 내에 큐를 생성하는 데 사용할 수 있다.

<br/>

마지막으로, 트리밍하기 전에 `$sort` 제한자를 `$push` 작업에 적용할 수 있다.

```sh
admin> db.blogs.posts.updateOne({ "title": "A blog post" },
... {"$push" : {"related" : {"$each" : [{"name" : "post1", "rating" : 2.0},
... {"name" : "post2", "rating" : 1.0},
... {"name" : "post3", "rating" : 3.0}],
... "$slice" : -2,
... "$sort" : {"rating" : -1}}}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blogs.posts.findOne()
{
  _id: ObjectId('677225b0b151887453fc0422'),
  title: 'A blog post',
  content: 'contents',
  comments: [ { name: 'joe', email: 'joe@example.com', content: 'nice posts.' } ],
  reviews: [
    1, 2, 3, 4, 5,
    6, 4, 5, 6, 4,
    5, 6
  ],
  top10: [ 3 ],
  related: [ { name: 'post1', rating: 2 }, { name: 'post2', rating: 1 } ]
}
```

<br/>

*배열을 집합으로 사용하기*

특정 값이 배열에 존재하지 않을 때 해당 값을 추가하면서, 배열을 집합처럼 처리하려면 쿼리 도큐먼트에 `$ne` 를 사용한다.

```sh
admin> db.blogs.posts.updateOne({"title": {"$ne" : "post2"}}, {"$push": {"reviewContent" : "contents3"}});
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blogs.posts.find({})
[
  {
    _id: ObjectId('677225b0b151887453fc0422'),
    title: 'A blog post',
    content: 'contents',
    comments: [
      { name: 'joe', email: 'joe@example.com', content: 'nice posts.' }
    ],
    reviews: [
      1, 2, 3, 4, 5,
      6, 4, 5, 6, 4,
      5, 6
    ],
    top10: [ 3 ],
    related: [
      { name: 'post3', rating: 5 },
      { name: 'post3', rating: 5 },
      { name: 'post3', rating: 5 },
      { name: 'post1', rating: 6 },
      { name: 'post2', rating: 7 }
    ],
    reviewContent: [ 'contents3' ]
  },
  {
    _id: ObjectId('677229dcb151887453fc0426'),
    title: 'post2',
    content: 'contents2'
  }
]
```

<br/>

`$addToSet` 을 사용할 수도 있다. `$addToSet` 을 사용하면 중복을 피할 수 있다.

```sh
admin> db.users.updateOne({"_id" : ObjectId('676e7528501ea8f45afc0424')}, {"$addToSet" : {"emails" : "joe@gmail.com"}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.users.findOne()
{
  _id: ObjectId('676e7528501ea8f45afc0424'),
  relationships: { friends: 32, enemies: 2 },
  username: 'joe',
  author: { name: 'joe2' },
  emails: [ 'joe@gmail.com' ]
}
```
- 고유한 값을 여러 개 추가하려면 `$addToSet` 과 `$each` 를 결합해 사용한다.

<br/>

중복을 피해서 두 개 이상의 값을 추가하려면 다음과 같이 연산자를 사용한다.

```sh
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    author: { name: 'joe2' },
    emails: [ 'joe@gmail.com', 'joe@email.com', 'joe2@email.com' ]
  }
]
admin> db.users.updateOne({ "_id": ObjectId('676e7528501ea8f45afc0424') }, { "$addToSet": { "emails": { "$each": ["joe@email.com", "joe2@email.com"] } } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 0,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('676e7528501ea8f45afc0424'),
    relationships: { friends: 32, enemies: 2 },
    username: 'joe',
    author: { name: 'joe2' },
    emails: [ 'joe@gmail.com', 'joe@email.com', 'joe2@email.com' ]
  }
]
```

<br/>

##### 요소 제거하기

배열의 양쪽 끝에서 요소를 제거하는 `$pop` 을 사용한다. `{"$pop" : {"key" : 1}}` 은 배열의 마지막부터 요소를 제거하고, `{"$pop" : {"key" : -1}}` 은 배열의 처음부터 요소를 제거한다. `$pull` 은 주어진 조건에 맞는 배열 요소를 제거하는 데 사용한다.

```sh
admin> db.lists.insertOne({"todo" : ["dishes", "laundry", "dry cleaning"]});
{
  acknowledged: true,
  insertedId: ObjectId('677388feb151887453fc0427')
}
admin> db.lists.find()
[
  {
    _id: ObjectId('677388feb151887453fc0427'),
    todo: [ 'dishes', 'laundry', 'dry cleaning' ]
  }
]
admin> db.lists.updateOne({}, {"$pull" : {"todo" : "laundry"}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.lists.find()
[
  {
    _id: ObjectId('677388feb151887453fc0427'),
    todo: [ 'dishes', 'dry cleaning' ]
  }
]
```
- `$pull` 은 도큐먼트에서 조건과 일치하는 요소를 모두 제거한다.
- 배열 연산자는 배열을 값으로 갖는 키에만 사용한다.
- 스칼라값을 변경하려면 `$set` 이나 `$inc` 를 사용한다.

<br/>

##### 배열의 위치 기반 변경

배열 내 여러 값을 다루려면 위치를 이용하거나 위치 연산자를 사용하면 된다. 배열 인덱스는 기준이 0이며, 배열 요소는 인덱스를 도큐먼트의 키처럼 사용한다.

배열의 첫 번째의 값을 변경하려면 다음과 같이 변경하면 된다.

```sh
admin> db.blog.posts.findOne()
{
  _id: ObjectId('67738a68b151887453fc0428'),
  content: 'asdasd',
  comments: [
    { comment: 'good post', author: 'John', votes: 0 },
    { comment: 'test1', author: 'tester1', votes: 3 },
    { comment: 'test2', author: 'tester2', votes: -5 }
  ]
}
admin> db.blog.posts.updateOne({ "comments.author": "John" }, { "$set": { "comments.$.author": "Jim" } });
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blog.posts.findOne()
{
  _id: ObjectId('67738a68b151887453fc0428'),
  content: 'asdasd',
  comments: [
    { comment: 'good post', author: 'Jim', votes: 0 },
    { comment: 'test1', author: 'tester1', votes: 3 },
    { comment: 'test2', author: 'tester2', votes: -5 }
  ]
}
```
- 몽고DB에서는 쿼리 도큐먼트와 일치하는 배열 요소 및 요소의 위치를 알아내서 갱신하는 위치 연산자 `$` 를 제공한다.
- 위치 연산자는 첫 번째로 일치하는 요소만 갱신한다.

<br/>

##### 배열 필터를 이용한 갱신

개별 배열 요소를 갱신하는 배열 필터인 `arrayFilters` 를 도입해 특정 조건에 맞는 배열 요소를 갱신할 수 있다.

```sh
admin> db.blog.posts.find()
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    content: 'asdasd',
    comments: [
      { comment: 'good post', author: 'Jim', votes: 0 },
      { comment: 'test1', author: 'tester1', votes: 3 },
      { comment: 'test2', author: 'tester2', votes: -5 }
    ]
  }
]
admin> db.blog.posts.updateOne( { "_id" : ObjectId('67738a68b151887453fc0428') }, { "$set": { "comments.$[elem].hidden": true } }, { arrayFilters: [{ "elem.votes": { $lte: -5 } }] } )
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 1,
  upsertedCount: 0
}
admin> db.blog.posts.find()
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    content: 'asdasd',
    comments: [
      { comment: 'good post', author: 'Jim', votes: 0 },
      { comment: 'test1', author: 'tester1', votes: 3 },
      { comment: 'test2', author: 'tester2', votes: -5, hidden: true }
    ]
  }
]
```
- `comments` 배열의 각 일치 요소에 대한 식별자로 `elem` 을 정의한다.
- `elem` 이 식별한 댓글의 투표값이 `-5` 이하면 `hidden` 필드를 추가하고 값을 `true` 로 설정한다.

<br/>

#### 3.3.3. 갱신 입력
---

**갱신 입력**은 특수한 형태를 갖는 갱신이다. 갱신 조건에 맞는 도큐먼트가 존재하지 않을 때 새로운 도큐먼트를 생성한다. 조건에 맞는 도큐먼트가 발견되면 일반적인 갱신을 수행한다.

갱신 입력을 사용하면 코드를 줄이고 경쟁 상태를 피할 수 있다. `updateOne` 과 `updateMany` 의 세 번째 매개변수는 옵션 도큐먼트로, 갱신 입력을 지정한다.

```sh
admin> db.analytics.updateOne({"url" : "/blog"}, {"$inc" : {"pageviews" : 1}}, {"upsert" : true})
{
  acknowledged: true,
  insertedId: ObjectId('6785cc7f2612814ad1e5ee49'),
  matchedCount: 0,
  modifiedCount: 0,
  upsertedCount: 1
}
admin> db.analytics.findOne()
{
  _id: ObjectId('6785cc7f2612814ad1e5ee49'),
  url: '/blog',
  pageviews: 1
}
```

<br/>

도큐먼트가 생성될 때 필드가 설정돼야 할 때가 종종 있는데, 이후 갱신에서는 변경되지 않아야 한다. 이때 `$setOneInsert` 를 사용한다. `$setOnInsert` 는 도큐먼트가 삽입될 때 필드 값을 설정하는 데만 사용하는 연산자다. 다음과 같이 사용한다.

```sh
admin> db.users.find()

admin> db.users.updateOne({}, { "$setOnInsert": { "createdAt": new Date() } }, { "upsert": true })
{
  acknowledged: true,
  insertedId: ObjectId('6785cf822612814ad1e5ee4a'),
  matchedCount: 0,
  modifiedCount: 0,
  upsertedCount: 1
}
admin> db.users.find()
[
  {
    _id: ObjectId('6785cf822612814ad1e5ee4a'),
    createdAt: ISODate('2025-01-14T02:44:18.513Z')
  }
]
admin> db.users.updateOne({}, { "$setOnInsert": { "createdAt": new Date() } }, { "upsert": true })
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 1,
  modifiedCount: 0,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('6785cf822612814ad1e5ee4a'),
    createdAt: ISODate('2025-01-14T02:44:18.513Z')
  }
]
```
- 다시 갱신하면 기존 도큐먼트를 찾고, 아무것도 입력되지 않으며, `createdAt` 필드는 변경되지 않는다.
- `$setOnInsert` 는 패딩을 생성하고 카운터를 초기화하는 데 쓰이며, `ObjectId` 를 사용하지 않는 컬렉션에 유용하다.

<br/>

##### 저장 셸 보조자

`save` 는 도큐먼트가 존재하지 않으면 도큐먼트를 삽입하고, 존재하면 도큐먼트를 갱신하게 하는 셸 함수다. 도큐먼트가 `_id` 키를 포함하면 `save` 는 갱신 입력을 실행하고, 포함하지 않으면 삽입을 실행한다.

<br/>

#### 3.3.4. 다중 도큐먼트 갱신
---

`updateOne` 은 필터 조건에 맞는 첫 번째 도큐먼트만 갱신한다. 조건에 맞는 도큐먼트를 모두 수정하려면 `updateMany` 를 사용하자.

`updateMany` 는 스키마를 변경하거나 특정 사용자에 새로운 정보를 추가할 때 쓰기 좋다.

```sh
admin> db.users.insertMany([{birthday: "10/13/1978"}, {birthday: "10/13/1978"}, {birthday: "10/13/1978"}])
{
  acknowledged: true,
  insertedIds: {
    '0': ObjectId('678625a83d7174bdf6fc0425'),
    '1': ObjectId('678625a83d7174bdf6fc0426'),
    '2': ObjectId('678625a83d7174bdf6fc0427')
  }
}
admin> db.users.find()
[
  { _id: ObjectId('678625a83d7174bdf6fc0425'), birthday: '10/13/1978' },
  { _id: ObjectId('678625a83d7174bdf6fc0426'), birthday: '10/13/1978' },
  { _id: ObjectId('678625a83d7174bdf6fc0427'), birthday: '10/13/1978' }
]
admin> db.users.updateMany({"birthday" : "10/13/1978"},
... {"$set" : {"gift" : "Happy Birthday!"}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 3,
  upsertedCount: 0
}
admin> db.users.find()
[
  {
    _id: ObjectId('678625a83d7174bdf6fc0425'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  },
  {
    _id: ObjectId('678625a83d7174bdf6fc0426'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  },
  {
    _id: ObjectId('678625a83d7174bdf6fc0427'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  }
]
```

<br/>

#### 3.3.5. 갱신한 도큐먼트 반환
---

`findOneAndDelete` , `findOneAndReplace` , `findOneAndUpdate` 를 통해 수정된 도큐먼트를 반환받을 수 있다. 도큐먼트의 값을 원자적으로 얻을 수 있으며, 갱신을 위한 집계 파이프라인을 수용하도록 `findOneAndUpdate` 를 확장했다. 파이프라인은 `$addFields($set)` , `$project($unset)` , `$replaceRoot($replaceWith)` 로 구성될 수 있다.

```sh
admin> db.process.findOneAndUpdate({ "status": "DONE" }, { "$set": { "status": "RUNNING" } }, { "sort": { "priority": -1 } })
{
  _id: ObjectId('678626e23d7174bdf6fc0429'),
  status: 'DONE',
  priority: 1
}
admin> db.process.find()
[
  {
    _id: ObjectId('678626e23d7174bdf6fc0429'),
    status: 'RUNNING',
    priority: 1
  }
]
```
- `findOneAndReplace` 는 동일한 매개변수를 사용하며, `returnNewDocument` 의 값에 따라 교체 전이나 후에 필터와 일치하는 도큐먼트를 반환한다.
- `findOneAndDelete` 도 유사하지만 갱신 도큐먼트를 매개변수로 사용하지 않으며 다른 두 메서드의 옵션을 부분적으로 가진다.
- `findOneAndDelete` 는 삭제된 도큐먼트를 반환한다.

<br/>

## 4. 쿼리
---

이 장에서는 쿼리를 자세히 살펴본다.

- `$` 조건절을 이용해 범위 쿼리, 셋의 포함 관계, 부동 관계 쿼리 등을 수행한다.
- 쿼리는 필요할 때마다 도큐먼트 배치를 반환하는 데이터베이스 커서를 반환한다.
- 커서를 이용해 결과를 몇 개 건너뛰거나, 반환하는 결과 수를 제한하거나, 결과를 정렬하는 등 다양한 메타 연산을 수행한다.

<br/>

### 4.1. find 소개
---

`find` 함수는 쿼리에 사용한다. 쿼리는 컬렉션에서 도큐먼트의 서브셋을 반환한다. 다음 명령은 컬렉션의 모든 도큐먼트와 일치하므로 모든 도큐먼트를 반환한다.

```sh
admin> db.c.find()
```

<br/>

쿼리 도큐먼트에 여러 키/값 쌍을 추가해 검색을 제한할 수 있다.

```sh
admin> db.users.find({"age" : 27})
admin> db.users.find({"username" : "joe"})
admin> db.users.find({"username" : "joe", "age" : 27})
```

<br/>

#### 4.1.1. 반환받을 키 지정
---

반환받을 도큐먼트 내 키/값 정보가 모두 필요하지 않을 수 있다. 그럴 때는 `find` 의 두 번째 매개변수에 원하는 키를 지정하면 된다.

```sh
admin> db.users.find()
[
  {
    _id: ObjectId('678625a83d7174bdf6fc0425'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  },
  {
    _id: ObjectId('678625a83d7174bdf6fc0426'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  },
  {
    _id: ObjectId('678625a83d7174bdf6fc0427'),
    birthday: '10/13/1978',
    gift: 'Happy Birthday!'
  }
]
admin> db.users.find({}, {"birthday":1})
[
  { _id: ObjectId('678625a83d7174bdf6fc0425'), birthday: '10/13/1978' },
  { _id: ObjectId('678625a83d7174bdf6fc0426'), birthday: '10/13/1978' },
  { _id: ObjectId('678625a83d7174bdf6fc0427'), birthday: '10/13/1978' }
]
admin> db.users.find({}, {"birthday":1, "_id": 0})
[
  { birthday: '10/13/1978' },
  { birthday: '10/13/1978' },
  { birthday: '10/13/1978' }
]
```
- `_id` 키는 지정하지 않아도 항상 반환된다.
- 두 번째 매개변수를 사용해서 특정 키/값 쌍을 제외한 결과를 얻을 수 있다.

<br/>

#### 4.1.2. 제약 사항
---

쿼리에는 몇 가지 제약이 있다. 쿼리 도큐먼트 값은 반드시 상수여야 한다. 이는 도큐먼트 내 다른 키의 값을 참조할 수 없음을 의미한다.

```sh
db.stock.find({"in_stock" : "this.num_sold"}) // 작동하지 않음
```

<br/>

### 4.2. 쿼리 조건
---

쿼리는 완전 일치 외에도 범위, OR절, 부정 조건 등 더 복잡한 조건으로 검색할 수 있다.

<br/>

#### 4.2.1. 쿼리 조건절
---

<, <=, >, >= 에 해당하는 비교 연산자는 각각 `$lt` , `$lte` , `$gt` , `$gte` 다. 조합해 사용하면 특정 범위 내 값을 쿼리할 수 있다.

```sh
admin> db.users.find({"age" : {"$gte" : 18, "$lte" : 30}})
```

<br/>

범위 쿼리는 날짜 쿼리에 유용하다.

```sh
admin> start = new Date("01/01/2007")
ISODate('2007-01-01T00:00:00.000Z')
admin> db.users.find({"registered" : {"$lt" : start}})
```

<br/>

키 값이 특정 값과 일치하지 않는 도큐먼트를 찾는 데는 `$ne` 를 사용한다.

```sh
admin> db.users.find({"username": {"$ne" : "joe"}})
```

<br/>

#### 4.2.2. OR 쿼리
---

OR 쿼리에는 두 가지 방법이 있다. `$in` 은 하나의 키를 다양한 값과 비교하는 쿼리에 사용한다. `$or` 은 더 일반적이며, 여러 키를 주어진 값과 비교하는 쿼리에 사용한다.

```sh
admin> db.raffle.find({"ticket_no" : {"$in" : [725, 542, 309]}})
```

<br/>

`$nin` 은 `$in` 과 반대로 배열 내 조건과 일치하지 않는 도큐먼트를 반환한다.

```sh
admin> db.raffle.find({"ticket_no" : {"$nin" : [725, 542, 390]}})
```

<br/>

`$or` 은 가능한 조건들의 배열을 취한다.

```sh
admin> db.raffle.find({"$or": [{"ticket_no" : 725}, {"winner" : true}]})
admin> db.raffle.find({"$or": [{"ticket_no" : {"$in" : [725, 542, 390]}}, {"winner": true}]})
```
- `$or` 연산자가 항상 작동하는 동안에는 가능한 한 `$in` 을 사용하자.
- 쿼리 옵티마이저는 `$in` 을 더 효율적으로 다룬다.

<br/>

#### 4.2.3. $not
---

`$not` 은 메타 조건절이며 어떤 조건에도 적용할 수 있다.

```sh
admin> db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
```
- `$not` 은 정규 표현식과 함께 사용해 주어진 패턴과 일치하지 않는 도큐먼트를 찾을 때 유용하다.

<br/>

### 4.3. 형 특정 쿼리
---

일부 데이터형은 쿼리 시 형에 특정하게 작동한다.

<br/>

#### 4.3.1. null
---

`null` 은 스스로 일치하는 것을 찾는다.

```sh
admin> db.c.find()
[
  { _id: ObjectId('678658d953857f4543fc0421'), y: null },
  { _id: ObjectId('678658d953857f4543fc0422'), y: 1 },
  { _id: ObjectId('678658d953857f4543fc0423'), y: 2 }
]
admin> db.c.find({"y": null})
[ { _id: ObjectId('678658d953857f4543fc0421'), y: null } ]
admin> db.c.find({"z": null})
[
  { _id: ObjectId('678658d953857f4543fc0421'), y: null },
  { _id: ObjectId('678658d953857f4543fc0422'), y: 1 },
  { _id: ObjectId('678658d953857f4543fc0423'), y: 2 }
]
```

<br/>

값이 `null` 인 키만 찾고 싶으면 키가 `null` 인 값을 쿼리하고, `$exists` 조건절을 사용해 `null` 존재 여부를 확인하면 된다.

```sh
admin> db.c.find({"z" : {"$eq" : null, "$exists" : true}})
```

<br/>

#### 4.3.2. 정규 표현식
---

`$regex` 는 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공한다.

```sh
admin> db.users.find({"name" : {"$regex" : /joe/i}})
```
- 대소문자 구분 없이 일치하는 문자를 찾는다.
- 정규 표현식 플래그(ex. `i`)는 사용할 수 있지만 꼭 필요하지는 않다.

<br/>

정규 표현식 일치에 펄 호환 정규 표현식(PCRE) 라이브러리를 사용하며, PCRE에서 쓸 수 있는 모든 문법은 몽고DB에서 쓸 수 있다.

<br/>

#### 4.3.3. 배열에 쿼리하기
---

배열 오소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계됐다.

```sh
admin> db.food.insertOne({"fruit" : ["apple", "banana", "peach"]})
{
  acknowledged: true,
  insertedId: ObjectId('67865ab353857f4543fc0424')
}
admin> db.food.find({"fruit" : "banana"})
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach' ]
  }
]
```

<br/>

##### $all 연산자

2개 이상의 배열 요소가 일치하는 배열을 찾으려면 `$all` 을 사용한다.

```sh
admin> db.food.find()
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach' ]
  },
  {
    _id: ObjectId('67865afc53857f4543fc0425'),
    fruit: [ 'apple', 'kumquat', 'orange' ]
  },
  {
    _id: ObjectId('67865b0753857f4543fc0426'),
    fruit: [ 'cherry', 'banana', 'orange' ]
  }
]
admin> db.food.find({fruit : {$all: ["apple", "banana"]}})
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach' ]
  }
]
```

<br/>

배열 내 특정 요소를 쿼리하려면 `key.index` 구문을 이용해 순서를 지정한다.

```sh
admin> db.food.find({"fruit.2" : "peach"})
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach' ]
  }
]
```

<br/>

##### $size 연산자

`$size` 는 특정 크기의 배열을 쿼리하는 유용한 조건절이다.

```sh
admin> db.food.find({"fruit": {"$size" : 3}})
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach' ]
  },
  {
    _id: ObjectId('67865afc53857f4543fc0425'),
    fruit: [ 'apple', 'kumquat', 'orange' ]
  },
  {
    _id: ObjectId('67865b0753857f4543fc0426'),
    fruit: [ 'cherry', 'banana', 'orange' ]
  }
]

admin> db.food.updateMany({}, {"$push" : {"fruit": "strawberry2"}, "$inc" : {"size" : 1}})
{
  acknowledged: true,
  insertedId: null,
  matchedCount: 3,
  modifiedCount: 3,
  upsertedCount: 0
}
admin> db.food.find()
[
  {
    _id: ObjectId('67865ab353857f4543fc0424'),
    fruit: [ 'apple', 'banana', 'peach', 'strawberry', 'strawberry2' ],
    size: 2
  },
  {
    _id: ObjectId('67865afc53857f4543fc0425'),
    fruit: [ 'apple', 'kumquat', 'orange', 'strawberry2' ],
    size: 1
  },
  {
    _id: ObjectId('67865b0753857f4543fc0426'),
    fruit: [ 'cherry', 'banana', 'orange', 'strawberry2' ],
    size: 1
  }
]
```

<br/>

##### $slice 연산자

`$slice` 연산자를 사용해서 배열 요소의 부분집합을 반환받을 수 있다.

```sh
admin> db.blog.posts.find()
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    content: 'asdasd',
    comments: [
      { comment: 'good post', author: 'Jim', votes: 0 },
      { comment: 'test1', author: 'tester1', votes: 3 },
      { comment: 'test2', author: 'tester2', votes: -5, hidden: true }
    ]
  }
]
admin> db.blog.posts.find({}, {"comments" : {"$slice" : 1}})
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    content: 'asdasd',
    comments: [ { comment: 'good post', author: 'Jim', votes: 0 } ]
  }
]
```

<br/>

`$slice` 는 또한 오프셋과 요소 개수를 지정해 원하는 범위 안에 있는 결과를 반환할 수 있다.

```sh
admin> db.blog.posts.find({}, {"comments" : {"$slice" : [1, 1]}})
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    content: 'asdasd',
    comments: [ { comment: 'test1', author: 'tester1', votes: 3 } ]
  }
]
```
- `-1` 은 마지막의 값을 가져온다.

<br/>

##### 일치하는 배열 요소의 반환

특정 기준과 일치하는 배열 요소를 원할 수도 있다. `$` 연산자를 사용하면 일치하는 요소를 반환받을 수 있다.

```sh
admin> db.blog.posts.find({"comments.author" : {"$regex" : /^tester/}}, {"comments.$": 1})
[
  {
    _id: ObjectId('67738a68b151887453fc0428'),
    comments: [ { comment: 'test1', author: 'tester1', votes: 3 } ]
  }
]
```

<br/>

##### 배열 및 범위 쿼리의 상호작용

도큐먼트 내 스칼라(비배열 요소)는 쿼리 기준의 각 절과 일치해야 한다.

```sh
admin> db.test.find({"x": {"$gt": 10, "$lt": 20}})
[
  { _id: ObjectId('67865ed353857f4543fc0428'), x: 15 },
  { _id: ObjectId('67865ed353857f4543fc042a'), x: [ 5, 25 ] }
]
```
- 25는 `$gt: 10` 에 일치하고, 5는 `$lt : 20` 에 일치하기 때문에 반환되었다.

<br/>

원하는 결과를 얻으려면 다음과 같이 몇 가지 방법을 사용해야 한다. 첫 번째 방법으로 `$elemMatch` 연산자를 사용하면 몽고DB는 두 절을 하나의 배열 요소와 비교한다. 하지만 `$elemMatch` 연산자는 비배열 요소를 일치시키지 않는다.

```sh
admin> db.test.find({"x": {"$elemMatch": {"$gt": 10, "$lt": 20}}})

admin> db.test.find({"x": {"$elemMatch": {"$gt": 10, "$lt": 30}}})
[ { _id: ObjectId('67865ed353857f4543fc042a'), x: [ 5, 25 ] } ]
```

<br/>

배열을 포함하는 도큐먼트에 범위 쿼리를 할 때 `min` 함수와 `max` 함수를 사용하면 좋다. 배열에 대한 `$gt`, `$lt` 쿼리의 인덱스 한계는 비효율적이다. 어떤 값이든 허용하므로 범위 내 값뿐 아니라 모든 인덱스 항목을 검색한다.

<br/>

#### 4.3.4. 내장 도큐먼트에 쿼리하기
---
내장 도큐먼트 쿼리는 도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉜다.

```sh
admin> db.people.find({"name": {"first": "Joe", "last": "Schmoe"}})
[
  {
    _id: ObjectId('678772b353857f4543fc042b'),
    name: { first: 'Joe', last: 'Schmoe' },
    age: 45
  }
]
```
- 이와 같이 내장 도큐먼트를 쿼리할 수 있다.
- 그러나 서브도큐먼트 전체에 쿼리하려면 서브도큐먼트와 정확히 일치해야 한다.

<br/>

내장 도큐먼트에 쿼리할 때는 가능하다면 특정 키로 쿼리하는 방법이 좋다. 내장 도큐먼트의 키를 쿼리할 때는 점 표기법을 사용한다.

```sh
admin> db.people.find({"name.first": "Joe", "name.last": "Schmoe"})
[
  {
    _id: ObjectId('678772b353857f4543fc042b'),
    name: { first: 'Joe', last: 'Schmoe' },
    age: 45
  }
]
```

<br/>

모든 키를 지정하지 않고도 조건을 정확하게 묶으려면 `$elemMatch` 를 사용한다. 이 조건절은 조건을 부분적으로 지정해 배열 내에서 하나의 내장 도큐먼트를 찾게 해준다.

```sh
admin> db.blog.insertOne({"content": "content", "comments": [
... {"author": "joe", "score": 3, "comment": "nice post"},
... {"author": "mary", "score": 6, "comment": "terrible post"}
... ]
... }
... )
{
  acknowledged: true,
  insertedId: ObjectId('6787746453857f4543fc042c')
}
```
- `$elemMatch` 를 사용해 조건을 그룹화할 수 있다. 따라서 내장 도큐먼트에서 2개 이상의 키의 조건 일치 여부를 확인할 때만 필요하다.

<br/>

### 4.4. $where 쿼리
---

`$where` 절을 사용해 임의의 자바스크립트를 쿼리의 일부분으로 실행하면 거의 모든 쿼리를 표현할 수 있다. 따라서 보안상의 이유로 `$where` 절 사용을 제한해야 한다.

```sh
admin> db.foo.insertOne({"apple": 1, "banana": 6, "peach": 3})
{
  acknowledged: true,
  insertedId: ObjectId('67877de153857f4543fc042d')
}
admin> db.foo.insertOne({"apple": 8, "spinach": 4, "watermelon": 4})
{
  acknowledged: true,
  insertedId: ObjectId('67877df453857f4543fc042e')
}
admin> db.foo.find({"$where": function() { for (var current in this) { for (var other in this) { if (current != other && this[current] == this[other]){ return true; } } } return false; }});
[
  {
    _id: ObjectId('67877df453857f4543fc042e'),
    apple: 8,
    spinach: 4,
    watermelon: 4
  }
]
```
- `$where` 쿼리는 일반 쿼리보다 훨씬 느리니 반드시 필요한 경우가 아니면 사용하지 말자. 또한 인덱스를 쓸 수 없다.
- `$where` 절은 결과를 세부적으로 조정할 때 사용하자.
- 집계 표현식을 사용할 수 있도록 `$expr` 연산자가 추가됐으므로 `$where` 대신 `$expr` 을 사용하자.

<br/>

### 4.5. 커서
---

데이터베이스는 커서를 사용해 find의 결과를 반환한다. 결과 개수를 제한하거나, 결과 중 몇 개를 건너뛰거나, 여러 키를 조합한 결과를 어떤 방향으로든 정렬하는 등 다양하게 조작할 수 있다.

```sh
admin> for(i=0; i<100; i++) {
... db.collection.insertOne({x : i});
... }
{
  acknowledged: true,
  insertedId: ObjectId('67877f3953857f4543fc0492')
}
admin> var cursor = db.collection.find();
```
- 간단한 컬렉션을 생성해 쿼리한 후 결과를 cursor 변수에 저장했다.

<br/>

결과를 얻으려면 커서의 `next` 메서드를 사용하고, 다른 결과가 있는지 확인하려면 `hasNext` 를 사용한다.

```sh
admin> while (cursor.hasNext()) {
... obj = cursor.next();
... print(obj);
... }
{ _id: ObjectId('67877f3953857f4543fc042f'), x: 0 }
{ _id: ObjectId('67877f3953857f4543fc0430'), x: 1 }
{ _id: ObjectId('67877f3953857f4543fc0431'), x: 2 }
{ _id: ObjectId('67877f3953857f4543fc0432'), x: 3 }
// 중간 생략
{ _id: ObjectId('67877f3953857f4543fc0492'), x: 99 }
```

<br/>

`forEach` 반목문에 사용할 수 있다.

```sh
admin> var cursor = db.people.find();

admin> cursor.forEach(function (x) { print(x.name); });
{ first: 'Joe', last: 'Schmoe' }
```
- `find` 를 호출할 때 셸이 데이터베이스를 즉시 쿼리하지는 않으며 결과를 요청하는 쿼리를 보낼 때까지 기다린다.

<br/>

예를 들어 다음 쿼리들은 모두 동일하게 작동한다.

```sh
admin> cursor.forEach(function (x) { print(x.name); })
admin> var cursor = db.collection.find().sort({"x": 1}).limit(1).skip(10);

admin> cursor
[ { _id: ObjectId('67877f3953857f4543fc0439'), x: 10 } ]
admin> var cursor = db.collection.find().limit(1).sort({"x": 1}).skip(10);

admin> cursor
[ { _id: ObjectId('67877f3953857f4543fc0439'), x: 10 } ]
admin> var cursor = db.collection.find().skip(10).limit(1).sort({"x": 1});

admin> cursor
[ { _id: ObjectId('67877f3953857f4543fc0439'), x: 10 } ]
```

<br/>

#### 4.5.1. 제한, 건너뛰기, 정렬
---

결과 개수를 제한하려면 `find` 호출에 `limit` 함수를 연결한다.

```sh
admin> db.collection.find().limit(3)
[
  { _id: ObjectId('67877f3953857f4543fc042f'), x: 0 },
  { _id: ObjectId('67877f3953857f4543fc0430'), x: 1 },
  { _id: ObjectId('67877f3953857f4543fc0431'), x: 2 }
]
```
- `limit` 은 상한만 설정하고 하한은 설정하지 않는다.

<br/>

`skip` 은 `limit` 와 유사하게 작동한다.

```sh
admin> db.collection.find().skip(3)
[
  { _id: ObjectId('67877f3953857f4543fc0432'), x: 3 },
  { _id: ObjectId('67877f3953857f4543fc0433'), x: 4 },
  { _id: ObjectId('67877f3953857f4543fc0434'), x: 5 },
  // 생략
```

<br/>

`sort` 는 객체를 매개변수로 받는다. 매개변수는 키/값 쌍의 셋, 키는 키의 이름, 값은 정렬 방향이다. 정렬 방향은 `1(오름차순)` 또는 `-1(내림차순)` 이다.

```sh
admin> db.collection.find().sort({x:1})
[
  { _id: ObjectId('67877f3953857f4543fc042f'), x: 0 },
  { _id: ObjectId('67877f3953857f4543fc0430'), x: 1 },
  { _id: ObjectId('67877f3953857f4543fc0431'), x: 2 },
  { _id: ObjectId('67877f3953857f4543fc0432'), x: 3 },
  ...

admin> db.collection.find().sort({x:-1})
[
  { _id: ObjectId('67877f3953857f4543fc0492'), x: 99 },
  { _id: ObjectId('67877f3953857f4543fc0491'), x: 98 },
  { _id: ObjectId('67877f3953857f4543fc0490'), x: 97 },
  ...
```

<br/>

페이지를 나눌 때 편리하다.

```sh
admin> db.collection.find().sort({x:1}).limit(5)
[
  { _id: ObjectId('67877f3953857f4543fc042f'), x: 0 },
  { _id: ObjectId('67877f3953857f4543fc0430'), x: 1 },
  { _id: ObjectId('67877f3953857f4543fc0431'), x: 2 },
  { _id: ObjectId('67877f3953857f4543fc0432'), x: 3 },
  { _id: ObjectId('67877f3953857f4543fc0433'), x: 4 }
]
admin> db.collection.find().sort({x:1}).limit(5).skip(5)
[
  { _id: ObjectId('67877f3953857f4543fc0434'), x: 5 },
  { _id: ObjectId('67877f3953857f4543fc0435'), x: 6 },
  { _id: ObjectId('67877f3953857f4543fc0436'), x: 7 },
  { _id: ObjectId('67877f3953857f4543fc0437'), x: 8 },
  { _id: ObjectId('67877f3953857f4543fc0438'), x: 9 }
]
```

<br/>

##### 비교 순서

몽고DB에는 데이터형을 비교하는 위계 구조가 있다. 정수형과 불리언형, 문자열형과 null형처럼 때로는 하나의 키에 여러 데이터형 값을 저장할 수 있다. 데이터형이 섞여 있는 키는 미리 정의된 순서에 따라 정렬한다. 데이터형 정렬 순서는 다음과 같다.

1. 최솟값
2. null
3. 숫자(int, long, double, decimal)
4. 문자열
5. 객체/도큐먼트
6. 배열
7. 이진 데이터
8. 객체 ID
9. 불리언
10. 날짜
11. 타임스탬프
12. 정규 표현식
13. 최댓값

<br/>

#### 4.5.2. 많은 수의 건너뛰기 피하기
---

`skip` 은 생략된 결과물을 모두 찾아 폐기하므로 결과가 많으면 느려진다. 따라서 많은 수의 건너뛰기는 피해야 한다.

<br/>

##### skip을 사용하지 않고 페이지 나누기

예를 들어 `date` 를 내림차순으로 정렬해 도큐먼트를 표시한다고 가정하자. 아래와 같이 첫 페이지를 구한다.

```sh
admin> var page1 = db.foo.find().sort({"date": -1}).limit(100)
```

<br/>

마지막 도큐먼트의 `date` 값을 사용해 다음 페이지를 가져온다.

```js
var latest = null;

// 첫 페이지 보여주기
while (page1.hasNext()) {
	latest = page1.next();
	display(latest);
}

// 다음 페이지 가져오기
var page2 = db.foo.find({"date" : {"$lt" : latest.date}});
page2.sort({"date" : -1}).limit(100);
```
- 이제 쿼리에 `skip` 을 쓸 필요가 없다.

<br/>

##### 랜덤으로 도큐먼트 찾기

도큐먼트를 입력할 때 랜덤 키를 별도로 추가하는 방법이다. 

```sh
admin> db.people.insertOne({"name": "joe", "random": Math.random()})
{
  acknowledged: true,
  insertedId: ObjectId('6787847753857f4543fc04f7')
}
admin> db.people.insertOne({"name": "john", "random": Math.random()})
{
  acknowledged: true,
  insertedId: ObjectId('6787847c53857f4543fc04f8')
}
admin> db.people.insertOne({"name": "jim", "random": Math.random()})
{
  acknowledged: true,
  insertedId: ObjectId('6787848053857f4543fc04f9')
}
admin> var random = Math.random()
admin> db.people.findOne({"random" : {"$gt" : random}})
{
  _id: ObjectId('6787847753857f4543fc04f7'),
  name: 'joe',
  random: 0.5306662954107095
}
```

<br/>

#### 4.5.3. 종료되지 않는 커서
---

서버 측에서 보면 커서는 메모리와 리소스를 점유한다. 커서가 더는 가져올 결과가 없거나 클라이언트로부터 종료 요청을 받으면 데이터베이스는 점유하고 있던 리소스를 해제한다.

서버 커서를 종료하는 몇 가지 조건이 있다. 첫 번째로, 커서는 조건에 일치하는 결과를 모두 살펴본 후에는 스스로 정리한다. 또한 커서가 클라이언트 측에서 유효 영역을 벗어나면 드라이버는 데이터베이스에 메시지를 보내 커서를 종료해도 된다고 알린다.

마지막으로, 사용자가 아직 결과를 다 살펴보지 않았고, 커서가 여전히 유효 영역 내에 있더라도 10분 동안 활동이 없으면 데이터베이스 커서는 자동으로 죽는다.

<br/>

## 5. 인덱싱
---

이 장에서는 다음을 알아본다.
- 인덱싱의 정의와 사용하는 이유
- 인덱싱할 필드를 선정하는 방법
- 인덱스 사용을 평가하고 적용하는 방법
- 인덱스 생성 및 제거에 대한 관리 정보

<br/>

### 5.1. 인덱싱 소개
---

인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 하며, 서버가 쿼리 결과를 찾으려면 '전체 내용을 살펴봐야 함'을 의미한다. 큰 컬렉션을 스캔할 때는 컬렉션 스캔이 매우 느려지니 이런 방식은 피하자.

<br/>

처음에는 인덱스를 사용하지 않고, 다음에는 인덱스를 사용해봄으로써 쿼리 성능 차이를 확인해보자.

```sh
# 1백만 건의 도큐먼트를 갖는 컬렉션 생성
admin> for (i=0; i<1000000; i++) {
... db.users.insertOne(
... { "i": i, "username": "user" + i, "age" : Math.floor(Math.random()*120), "created": new Date() });
... }
```

<br/>

`explain` 함수를 이용해 쿼리가 실행될 때 몽고DB가 무엇을 하는지 확인할 수 있다. `explain` 커서 메서드는 다양한 CRUD 작업의 실행 정보를 제공한다. 이 메서드는 여러 가지 모드를 실행할 수 있다. `executionStats` 모드는 인덱스를 이용한 쿼리의 효과를 이해하는 데 도움이 된다.

```sh
admin> db.users.find({"username": "user101"}).explain("executionStats")
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'admin.users',
    parsedQuery: { username: { '$eq': 'user101' } },
    indexFilterSet: false,
    planCacheShapeHash: '1DCAA255',
    planCacheKey: 'E4474531',
    optimizationTimeMillis: 0,
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    prunedSimilarIndexes: false,
    winningPlan: {
      isCached: false,
      stage: 'COLLSCAN',
      filter: { username: { '$eq': 'user101' } },
      direction: 'forward'
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 221,
    totalKeysExamined: 0,
    totalDocsExamined: 1000000,
    executionStages: {
      isCached: false,
      stage: 'COLLSCAN',
      filter: { username: { '$eq': 'user101' } },
      nReturned: 1,
      executionTimeMillisEstimate: 195,
      works: 1000001,
      advanced: 1,
      needTime: 999999,
      needYield: 0,
      saveState: 14,
      restoreState: 14,
      isEOF: 1,
      direction: 'forward',
      docsExamined: 1000000
    }
  },
  command: { find: 'users', filter: { username: 'user101' }, '$db': 'admin' },
  serverInfo: {
    host: '2ae17a4d2a79',
    port: 27017,
    version: '8.0.4',
    gitVersion: 'bc35ab4305d9920d9d0491c1c9ef9b72383d31f9'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted',
    internalQueryPlannerIgnoreIndexWithCollationForRegex: 1
  },
  ok: 1
}
```
- `totalDocsExamined` 는 쿼리를 실행하면서 살펴본 도큐먼트 개수이며, 보다시피 컬렉션에 들어 있는 모든 도큐먼트 개수와 같다.
- `executionTimeMillis` 필드는 쿼리하는 데 걸린 시간을 밀리초 단위로 보여준다.
- `nReturned` 필드는 반환받은 결과의 개수를 보여준다.

<br/>

쿼리에 효율적으로 응답하게 하려면 애플리케이션의 모든 쿼리 패턴에 인덱스를 사용해야 한다. 쿼리 패턴이란 애플리케이션이 데이터베이스에 요구하는 다양한 유형의 질문을 의미한다.

<br/>

#### 5.1.1. 인덱스 생성
---

인덱스를 만들려면 `createIndex` 컬렉션 메서드를 사용한다.

```sh
admin> db.users.createIndex({"username": 1})
username_1
```
- `db.currentOp()` 를 실행하거나 `mongod` 의 로그를 확인해 인덱스 구축의 진행률을 체크할 수 있다.

<br/>

인덱스 구축이 완료되면 다시 쿼리해보자.

```sh
admin> db.users.find({"username": "user101"}).explain("executionStats")
{
  explainVersion: '1',
  queryPlanner: {
    namespace: 'admin.users',
    parsedQuery: { username: { '$eq': 'user101' } },
    indexFilterSet: false,
    planCacheShapeHash: '1DCAA255',
    planCacheKey: 'AEA547E9',
    optimizationTimeMillis: 0,
    maxIndexedOrSolutionsReached: false,
    maxIndexedAndSolutionsReached: false,
    maxScansToExplodeReached: false,
    prunedSimilarIndexes: false,
    winningPlan: {
      isCached: false,
      stage: 'FETCH',
      inputStage: {
        stage: 'IXSCAN',
        keyPattern: { username: 1 },
        indexName: 'username_1',
        isMultiKey: false,
        multiKeyPaths: { username: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { username: [ '["user101", "user101"]' ] }
      }
    },
    rejectedPlans: []
  },
  executionStats: {
    executionSuccess: true,
    nReturned: 1,
    executionTimeMillis: 5,
    totalKeysExamined: 1,
    totalDocsExamined: 1,
    executionStages: {
      isCached: false,
      stage: 'FETCH',
      nReturned: 1,
      executionTimeMillisEstimate: 0,
      works: 2,
      advanced: 1,
      needTime: 0,
      needYield: 0,
      saveState: 0,
      restoreState: 0,
      isEOF: 1,
      docsExamined: 1,
      alreadyHasObj: 0,
      inputStage: {
        stage: 'IXSCAN',
        nReturned: 1,
        executionTimeMillisEstimate: 0,
        works: 2,
        advanced: 1,
        needTime: 0,
        needYield: 0,
        saveState: 0,
        restoreState: 0,
        isEOF: 1,
        keyPattern: { username: 1 },
        indexName: 'username_1',
        isMultiKey: false,
        multiKeyPaths: { username: [] },
        isUnique: false,
        isSparse: false,
        isPartial: false,
        indexVersion: 2,
        direction: 'forward',
        indexBounds: { username: [ '["user101", "user101"]' ] },
        keysExamined: 1,
        seeks: 1,
        dupsTested: 0,
        dupsDropped: 0
      }
    }
  },
  command: { find: 'users', filter: { username: 'user101' }, '$db': 'admin' },
  serverInfo: {
    host: '2ae17a4d2a79',
    port: 27017,
    version: '8.0.4',
    gitVersion: 'bc35ab4305d9920d9d0491c1c9ef9b72383d31f9'
  },
  serverParameters: {
    internalQueryFacetBufferSizeBytes: 104857600,
    internalQueryFacetMaxOutputDocSizeBytes: 104857600,
    internalLookupStageIntermediateDocumentMaxSizeBytes: 104857600,
    internalDocumentSourceGroupMaxMemoryBytes: 104857600,
    internalQueryMaxBlockingSortMemoryUsageBytes: 104857600,
    internalQueryProhibitBlockingMergeOnMongoS: 0,
    internalQueryMaxAddToSetBytes: 104857600,
    internalDocumentSourceSetWindowFieldsMaxMemoryBytes: 104857600,
    internalQueryFrameworkControl: 'trySbeRestricted',
    internalQueryPlannerIgnoreIndexWithCollationForRegex: 1
  },
  ok: 1
}
```
- `totalDocsExamined` 값이 1인 것을 볼 수 있다.

<br/>

인덱싱된 필드를 변경하는 쓰기(삽입, 갱신, 삭제) 작업은 더 오래 걸린다. 데이터가 변경될 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신해야 하기 때문이다.

<br/>

#### 5.1.2. 복합 인덱스 소개
---

상당수의 쿼리 패턴은 두 개 이상의 키를 기반으로 인덱스를 작성해야 한다. 인덱스가 앞부분에 놓일 때만 정렬에 도움이 된다. 즉, 다음 정렬에 큰 도움이 되지 않는다.

```sh
admin> db.users.find().sort({"age": 1, "username": 1}).explain("executionStats")
```

<br/>

위 정렬을 최적화하려면 `age` 와 `username` 에 인덱스를 만들어야 한다.

```sh
admin> db.users.createIndex({"age": 1, "username": 1})
age_1_username_1
```
- 이는 복합 인덱스라 불리며, 쿼리에서 정렬 방향이 여러 개이거나 검색 조건에 여러 개의 키가 있을 때 유용하다.
- 각 인덱스 항목은 나이와 사용자명을 포함하고 레코드 식별자를 가리킨다.

<br/>

실행하는 쿼리의 종류에 따라 인덱스를 사용하는 방법이 다르다. 가장 많이 사용하는 세 가지 방법을 알아보자.

- `db.users.find({"age" : 21}).sort({"username" : -1})`
	- `{"age" : 21}` 과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색한다.
- `db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})`
	- 인덱스에 있는 첫 번째 키인 `age` 를 사용해 일치하는 도큐먼트를 반환받는다.
- `db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})`
	- 이전처럼 몽고DB는 검색 조건에 맞는 인덱스를 사용한다.

<br/>

복합 인덱스를 구성할 때는 정렬 키를 첫 번째에 놓으면 좋다.

<br/>

#### 5.1.3. 몽고DB가 인덱스를 선택하는 방법
---

쿼리가 들어오면 몽고DB는 쿼리 모양을 확인한다. 모양은 검색할 필드와 정렬 여부 등 추가 정보와 관련 있다. 시스템은 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별한다.

쿼리가 들어오고 인덱스 5개 중 3개가 쿼리 후보로 식별됐다고 가정해보자. 몽고DB는 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만들고, 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다.

이 과정은 레이스와 같다. 앞으로 동일한 모양을 가진 쿼리에 사용할 인덱스로 선택된다. 플랜은 일정 기간 동안 서로 경쟁하며, 각 레이스의 결과로 전체 승리 플랜을 산출한다.

서버는 쿼리 플랜의 캐시를 유지하는데, 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다. 컬렉션과 인덱스가 변경되면 쿼리 플랜이 캐시에서 제거되고, 몽고DB는 다시 가능한 쿼리 플랜을 실험해 해당 컬렉션 및 인덱스 집합에 가장 적합한 플랜을 찾는다.

<br/>

#### 5.1.4. 복합 인덱스 사용
---

읽기와 쓰기를 가능한한 효율적으로 수행하도록 인덱스를 설계하자. 인덱스를 올바르게 설계하려면 실제 워크로드에서 인덱스를 테스트하고 조정해야 하지만, 몇 가지 모범 사례를 적용해볼 수 있다.

먼저 인덱스의 선택성을 고려한다. 쿼리를 충족하는 데 필요한 모든 작업을 고려해야 하며 때로는 트레이드오프가 필요하다.

<br/>

먼저 인덱스 두 개로 시작해서 몽고DB가 쿼리를 충족하기 위해 이러한 인덱스를 어떻게 사용하는지 살펴본다. 쿼리를 실행하면 `explain` 메서드의 출력은 몽고DB가 인덱스를 어떻게 사용해서 쿼리를 충족했는지 알려준다. `executionStats` 필드는 선정된 쿼리 플랜에 대해 완료된 쿼리 실행을 설명하는 통계를 포함한다.

`executionStats` 에서 먼저 `totalKeysExamined` 를 살펴보자. 이는 인덱스 내에서 몇 개의 키를 통과했는지 나타낸다. `totalKeysExamined` 를 `nReturned` 와 비교하면 쿼리와 일치하는 도큐먼트를 찾으려고 얼마나 많은 인덱스를 통과했는지 알 수 있다. 이로써 쿼리를 충족하는 데 사용된 인덱스가 선택적이지 않은지를 확인하면 된다.

`explain` 출력 맨 위에는 쿼리 플랜이 있다(`winningPlan` 참조). 쿼리 플랜은 쿼리를 충족하는 데 사용한 단계를 설명한다. 이는 서로 다른 쿼리 플랜이 경쟁한 결과이다. 우리는 사용한 인덱스 종류와 인메모리 정렬을 수행해야 하는지 여부에 관심을 둬야 한다.

`explain` 출력은 쿼리 플랜을 단계 트리로 표시한다. 각 단계에는 하위 단계 개수에 따라 하나 이상의 입력 다녜까 있을 수 있다. 입력 단계는 도큐먼트나 인덱스 키를 상위 단계에 제공한다. 쿼리 플랜에 `SORT` 단계가 표시된다면, 이는 데이터베이스에서 결과 셋을 정렬할 때 인덱스를 사용할 수 없었으며 대신 인메모리 정렬을 했다는 의미다.

<br/>

커서 `hint` 메서드를 사용하면 모양이나 이름을 지정함으로써 사용할 인덱스를 지정할 수 있다. 인덱스 필터는 쿼리, 정렬, 프로젝션 사양의 조합인 쿼리 모양을 사용한다. `planCacheSetFilter` 함수를 인덱스 필터와 함께 사용하면, 쿼리 옵티마이저가 인덱스 필터에 지정된 인덱스만 고려하도록 제한할 수 있다.

```sh
admin> db.users
			.find({"age" : {"$gte" : 21, "$lte" : 30}})
			.sort({"username" : 1})
			.hint({username:1})
			.explain("executionStats")
```

<br/>

모든 데이터셋에 해당되지는 않지만, 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야 한다.

복합 인덱스를 설계할 때는 인덱스를 사용할 공통 쿼리 패턴의 동등 필터, 다중값 필터, 정렬 구성 요소를 처리하는 방법을 알아야 한다. 이러한 세 가지 요소는 모든 복합 인덱스 설계 시 고려해야 하며, 인덱스를 올바르게 설계하면 몽고DB에서 최상의 쿼리 성능을 얻을 수 있다.

인덱스를 더 잘 설계하면 인메모리 정렬을 피할 수 있다. 이를 통해 데이터셋 크기와 시스템 부하와 관련해 보다 쉽게 확장할 수 있다.

하지만 복합 인덱스를 설계할 때는 일반적으로 트레이드오프가 있다.

복합 인덱스에서 자주 발생하는 문제로, 인메모리 정렬을 피하려면 반환하는 도큐먼트 개수보다 더 많은 키를 검사해야 한다. 즉 복합 인덱스 키 사이에 정렬 필드를 포함해야 한다. 정렬 구성 요소는 동등 필터 바로 뒤, 다중값 필터 앞에 포함한다. 이 인덱스는 쿼리에서 고려하는 키 집합을 매우 선택적으로 좁힌다.

<br/>

요약하면 복합 인덱스를 설계할 때,
- 동등 필터에 대한 키를 맨 앞에 표시해야 한다.
- 정렬에 사용되는 키는 다중값 필드 앞에 표시해야 한다.
- 다중값 필터에 대한 키는 마지막에 표시해야 한다.

<br/>

##### 키 방향 선택하기

두 개 이상의 검색 조건으로 정렬할 때는 인덱스 키의 방향이 서로 달라야 한다. 복합 정렬을 서로 다른 방향으로 최적화하려면 방향이 맞는 인덱스를 사용해야 한다.

인덱스 방향은 다중 조건에 따라 정렬할 때만 문제가 된다. 단일 키로 정렬하면 몽고DB는 인덱스를 쉽게 역순으로 읽을 수 있다.

<br/>

##### 커버드 쿼리 사용하기

쿼리가 단지 인덱스에 포함된 필드를 찾는 중이라면 도큐먼트를 가져올 필요가 없다. 인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드된다고 한다. 도큐먼트로 되돌아가지 말고 항상 커버드 쿼리를 사용하자.

쿼리가 확실히 인덱스만 사용하게 하려면 `_id` 필드를 반환받지 않도록 반환받을 키를 지정해야 한다. 쿼리하지 않는 필드에 인덱스를 만들어야 할 수도 있으므로, 쓰기 때문에 늘어날 부하와 쿼리 속도를 잘 조율해야 한다.

커버드 쿼리에 `explain` 을 실행하면 결과에 `FETCH` 단계의 하위 단계가 아닌 `IXSCAN` 단계가 있으며, `executionStats` 에서는 `totalDocsExamined` 의 값이 0이 된다.

<br/>

##### 암시적 인덱스

복합 인덱스는 이중 임무를 수행할 수 있으며 쿼리마다 다른 인덱스처럼 동작할 수 있다. 인덱스가 N개의 키를 가진다면 키들의 앞부분은 공짜 인덱스가 된다. 예를 들어 `{"a": 1, "b": 1, "c": 1, ..., "z": 1}` 과 같은 인덱스가 있다면 사실상 `{"a": 1}` , `{"a": 1, "b": 1}` , `{"a": 1, "b": 1, "c": 1}` 등으로 인덱스를 가진다.

<br/>

#### 5.1.5. $ 연산자의 인덱스 사용법
---

##### 비효율적인 연산자

일반적으로 부정 조건은 비효율적이다. `$ne` 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지 못한다. 

`$not` 은 종종 인덱스를 사용하는데, 어떻게 사용해야 하는지 모를 때가 많다. `$not` 은 기초적인 범위와 정규 표현식을 반대로 뒤집을 수 있다. 하지만 대두분은 테이블 스캔을 수행한다. `$nin` 은 항상 테이블 스캔을 수행한다.

<br/>

##### 범위

복합 인덱스는 다중 절 쿼리를 효율적으로 실행하도록 돕는다. 다중 필드로 인덱스를 설계할 때는 완전 일치가 사용될 필드를 첫 번째에, 범위가 사용될 필드를 마지막에 놓자. 하나의 쿼리에 두 개의 범위를 사용하면 비효율적인 쿼리 플랜이 된다.

<br/>

##### OR 쿼리

쿼리당 하나의 인덱스만 사용할 수 있다. 유일한 예외는 `$or` 다. `$or` 는 두 개의 쿼리를 수행하고 결과를 합치므로 `$or` 은 절마다 하나씩 인덱스를 사용할 수 있다. 일반적으로 두 번 쿼리해서 결과를 병합하면 한 번 쿼리할 때보다 훨씬 비효율적이다. 그러니 가능하면 `$or` 보다는 `$in` 을 사용하자.

`$or` 을 사용해야 한다면 두 쿼리의 결과를 조사하고 중복을 모두 제거해야 함을 명시하자.

<br/>

#### 5.1.6. 객체 및 배열 인덱싱
---

도큐먼트 내부에 도달해서 내장 필드와 배열에 인덱스를 생성하도록 허용한다. 내장 객체와 배열 필드는 복합 인덱스에서 최상위 필드와 결합될 수 있으며, 다소 특수한 경우를 제외하면 대부분 일반적인 인덱스 필드와 같은 방식으로 동작한다.

<br/>

##### 내장 도큐먼트 인덱싱하기

인덱스는 일반적인 키에 생성될 때와 동일한 방식으로 내장 도큐먼트 키에 생성될 수 있다. 서브필드에 인덱스를 만들어 해당 필드를 이용하는 쿼리의 속도를 높일 수 있다.

```sh
db.users.createIndex({"loc.city" : 1})
```
- 서브도큐먼트 전체를 인덱싱하면, 서브도큐먼트 전체에 쿼리할 때만 도움이 된다.

<br/>

##### 배열 인덱싱하기

배열에도 인덱스를 생성할 수 있다. 인덱스를 사용하면 배열의 특정 요소를 효율적으로 찾을 수 있다. 

배열을 인덱싱하면 배열의 각 요소에 인덱스 항목을 생성하므로 도큐먼트별로 인덱스 항목을 가진다. 따라서 입력, 갱신, 제거 작업을 하려면 모든 배열 요소가 갱신돼야 하므로 배열 인덱스를 단일값 인덱스보다 더 부담스럽게 만든다.

배열 요소에 대한 인덱스에는 위치 개념이 없다. 따라서 `comments.4` 와 같이 특정 배열 요소를 찾는 쿼리에는 인덱스를 사용할 수 없다.

<br/>

배열의 특정 항목에 인덱스를 생성할 수는 있다.

```sh
db.blog.createIndex({"comments.10.votes" : 1})
```
- 이 인덱스는 정확히 11번째 배열 요소를 쿼리할 때만 유용하다.

<br/>

인덱스 항목의 한 필드만 배열로부터 가져올 수 있다.

```sh
# 정상
db.multi.insert({"x" : [1, 2, 3], "y" : 1})

# 정상
db.multi.insert({"x" : 1, "y" : [1, 2, 3]})

# 비정상
db.multi.insert({"x" : [1, 2, 3], "y" : [1, 2, 3]})
```

<br/>

##### 다중키 인덱스가 미치는 영향

어떤 도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시된다. `explain()` 출력을 보면 인덱스가 다중키 인덱스인지 확인할 수 있으며, 다중키 인덱스가 사용됐다면 `isMultiKey` 필드는 `true` 다.

다중키 인덱스는 비다중키 인덱스보다 약간 느릴 수 있다. 하나의 도큐먼트를 여러 개의 인덱스 항목이 가리킬 수 있으므로 몽고DB는 결과를 반환하기 전에 중복을 제거해야 한다.

<br/>

#### 5.1.7. 인덱스 카디널리티
---

**카디널리티**는 컬렉션의 한 필드에 대한 고유값이 얼마나 많은지 나타낸다. 일반적으로 필드의 카디널리티가 높을수록 인덱싱이 더욱 도움이 된다.

일반적으로 높은 카디널리티 키를 생성하면 좋다. 적어도 복합 인덱스에서 높은 카디널리티 키를 낮은 카디널리티 키보다 앞에 놓자.

<br/>

### 5.2. explain 출력
---
`explain` 은 쿼리에 대한 많은 정보를 제공하며, 느린 쿼리를 위한 중요한 진단 도구다. 쿼리의 `explain` 출력을 보면 어떤 인덱스가 어떻게 사용되는지 알 수 있다.

쿼리가 `COLLSCAN` 을 사용하면 인덱스를 사용하지 않음을 알 수 있다. `totalKeysExamined` 는 검색한 인덱스 항목 개수를 보고하며 `totalDocsExamined` 는 검색한 도큐먼트 개수를 나타낸다. `executionTimeMillis` 는 서버가 요청을 받고 응답을 보낸 시점까지 쿼리가 얼마나 빨리 실행됐는지 보고한다. 이는 최고로 뽑힌 플랜이 아니라 모든 플랜이 실행되기까지 걸린 시간을 반영한다.

<br/>

중요한 필드 몇 가지를 자세히 살펴보자.

- `isMultiKey` : 다중키 인덱스 사용 여부
- `nReturned` : 쿼리에 의해 반환된 도큐먼트 개수
- `totalDocsExamined` : 디스크 내 실제 도큐먼트를 가리키는 인덱스 포인터를 따라간 횟수
- `totalKeysExamine` : 인덱스가 사용됐다면 살펴본 인덱스 항목 개수, 테이블 스캔을 했다면 조사한 도큐먼트 개수
- `stage` : 인덱스를 사용해 쿼리할 수 있었는지 여부. `COLSCAN` 은 인덱스로 쿼리할 수 없어 컬렉션 스캔을 수행했음을 뜻한다.
- `needYields` : 쓰기 요청을 처리하도록 쿼리가 양보(일시 중지)한 횟수. 대기 중인 쓰기가 있다면 쿼리는 일시적으로 락을 해제하고 쓰기가 처리되게 한다.
- `executionTimeMillis` : 데이터베이스가 쿼리하는 데 걸린 시간
- `indexBounds` : 인덱스가 어떻게 사용됐는지 설명하며 탐색한 인덱스의 범위를 제공한다.

<br/>

### 5.3. 인덱스를 생성하지 않는 경우
---

인덱스는 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적인데, 인덱스를 하나 사용하려면 두 번의 조회를 해야 하기 때문이다.

대체로 쿼리가 컬렉션의 30% 이상을 반환하는 경우 인덱스는 종종 쿼리를 늦춘다.

| 인덱스가 적합한 경우 | 컬렉션 스캔이 적합한 경우 |
| ----------- | -------------- |
| 큰 컬렉션       | 작은 컬렉션         |
| 큰 도큐먼트      | 작은 도큐먼트        |
| 선택적 쿼리      | 비선택적 쿼리        |

<br/>

### 5.4. 인덱스 종류
---

인덱스를 구축할 때 인덱스 옵션을 지정해 동작 방식을 바꿀 수 있다.

<br/>

#### 5.4.1. 고유 인덱스
---

고유 인덱스는 각 값이 인덱스에 최대 한 번 나타나도록 보장한다. 특정 도큐먼트에 대해서만 `partialFilterExpression` 으로 고유 인덱스를 만들면 된다.

```sh
admin> db.users.createIndex({"username": 1}, {"unique": true, "partialFilterExpression" : {"username": {$exists: true} } } )
username_1
```
- 동일한 값을 입력할 경우 중복 키 예외를 발생시키면 매우 비효율적이므로, 수많은 중복을 필터링하기보다는 가끔씩 발생하는 중복에 고유 제약 조건을 사용한다.

<br/>

##### 복합 고유 인덱스

복합 고유 인덱스를 만들 수도 있다. 이때 개별 키는 같은 값을 가질 수 있지만 인덱스 항목의 모든 키에 걸친 값의 조합은 인덱스에서 최대 한 번만 나타난다.

<br/>

##### 중복 제거하기

기존 컬렉션에 고유 인덱스를 구축할 때 중복된 값이 있으면 실패한다.

<br/>

#### 5.4.2. 부분 인덱스
---

고유한 필드가 존재하거나 필드가 아예 존재하지 않으면 `unique` 와 `partial` 을 결합할 수 있다. 부분 인덱스를 만들려면 `partialFilterExpression` 옵션을 포함시킨다. 부분 인덱스는 생성하려는 필터 표현식을 나타내는 도큐먼트와 함께 희소 인덱스가 제공하는 기능의 슈퍼셋을 나타낸다.

부분 인덱스는 반드시 고유할 필요는 없다. 고유하지 않은 부분 인덱스를 만들려면 `unique` 옵션을 제외시키기만 하면 된다.

<br/>

### 5.5. 인덱스 관리
---

데이터베이스의 인덱스 정보는 모두 `system.indexes` 컬렉션에 저장된다. 특정 컬렉션의 모든 인덱스 정보를 확인하려면 `db.컬렉션명.getIndexes()` 를 실행한다.

`key` 는 힌트에 사용하거나, 인덱스가 명시돼야 하는 위치에 사용할 수 있다. `v` 필드는 내부적으로 인덱스 버저닝에 사용된다.

<br/>

#### 5.5.1. 인덱스 식별
---

#### 5.5.2. 인덱스 변경
---

<br/>

## Reference
---

[한빛미디어: 몽고DB 완벽 가이드](https://www.yes24.com/product/goods/97980005)