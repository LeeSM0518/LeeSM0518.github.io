---
title: 삭제 API 성능 개선 (1분 -> 1초)
date: 2024-07-10 00:00:00 +0900
categories: troubleshooting
tags:
  - troubleshooting
  - performance-tuning
description: 영상을 비동기로 삭제하고, 테이블에 인덱스를 구성하여 60배 성능 향상
---

## 배경 및 목적

테스트 엔지니어가 위성영상 삭제를 테스트 하는 도중에 에러가 발생하여 버그를 리포트했다. 버그를 확인해보기 위해 직접 **버그를 재현 해보니 504(Gateway Timeout) 에러가 발생**하는 것을 확인했다. 어디에서 병목이 발생하여 504 에러가 발생하는 것인지 확인하고 **1분 미만으로 성능을 개선하는 것을 목표**로 작업을 시작했다.

## 개선 전 성능 측정

개선하기 전에 성능 측정을 먼저 진행한 결과, 테스트 서버에서 영상 50개를 삭제할 때 타임아웃이 발생하므로 **약 1분**으로 결정했다.

## 1차 원인 분석

타임아웃이 발생하는 API의 코드를 확인하여 **로직을 분석**했다. 해당 로직은 다음과 같다.

1. *영상 식별자 목록을 수신*
2. *영상 목록 조회*
3. *DB에서 삭제할 영상과 관련된 데이터들과 영상 데이터 제거*
4. *영상 목록을 순회하면서 영상 파일 제거*
5. *영상 목록을 순회하면서 삭제 이벤트 발행*

예상되는 **원인은 영상 목록을 순회하면서 영상 파일을 제거하는 코드를 동기적으로 수행하는 것**이였다. 그 이유는 영상의 크기가 10MB에서 30GB까지 크기가 다양한데 만약 삭제하려는 **파일들이 전부 몇 GB일 경우에 타임아웃이 발생할 것**이기 때문이다. 

## 1차 성능 개선

기존의 다음과 같이 **코루틴을 활용하여 비동기로 영상 목록을 삭제하도록 코드를 수정**했다.
```kotlin
private fun deleteSceneFiles(scenes: List<Scene>) {
  CoroutineScope(Dispatchers.IO).launch {
    runCatching {
      scenes.forEach {
        File(it.meta.path).delete()
        File("/scenes/link/${it.name}").delete()
      }
    }.onFailure {
      val sceneNames = scenes.map { it.name }
      logger.error(it) { "영상 삭제를 실패했습니다 [ scenes : $sceneNames ]" }
    }
  }
}
```

빌드하여 테스트 서버로 배포하고 정상 동작 여부와 소요시간을 확인했다.

## 1차 성능 측정

이전에 성능측정 할 때 사용한 영상들 50개를 다시 넣은 후에 삭제 API를 호출해봤다. 결과를 확인해보니 정상적으로 영상이 삭제됐으며, 17초가 소요되어 **약 3.5배 성능이 향상**된 것을 볼 수 있었다. 이제 타임아웃 에러는 발생하지 않아 버그 수정은 완료했으나, 17초도 사용자에게는 느리다고 느껴지기 때문에 **추가적으로 개선 작업을 진행**했다.

## 2차 원인 분석

어느 부분에서 병목이 발생하는지 확인하기 위해 각 로직마다 소요시간 측정 로깅 코드를 넣고 배포한 후에 테스트를 수행했다. 로그를 확인해보니 영상 데이터를 삭제하는 **DELETE 쿼리에서 15초가 소요**되는 것을 볼 수 있었다.

그 후 임의로 영상 데이터를 **하나 넣고 삭제해봤더니 3초가 소요**되는 것을 볼 수 있었다. 병목의 원인을 상세하게 살펴보기 위해 DELETE 쿼리의 병목 구간을 확인하기 위해 다음 쿼리를 사용하여 **실행 계획을 확인**했다.
```sql
EXPLAIN (ANALYZE, BUFFERS, TIMING)  
DELETE FROM scene where name = 'wv3_20241110000000_1';
```

결과를 확인해보니 3개의 제약 조건에서 각각 약 1초씩 걸린 것으로 확인됐다. 해당 제약 조건은 영상 식별자에 대한 FK 제약 조건이였으며, 삭제하려는 영상 식별자가 테이블에 존재하는지 확인하는데 오래 걸린다는 것을 알 수 있었다. 

## 2차 문제 해결

병목이 발생하는 제약 조건이 걸린 테이블에 영상 식별자로 인덱스를 생성해주고, 삭제 쿼리의 소요시간을 확인해보니 3ms로 줄어든 것을 볼 수 있었다. 즉, **삭제 쿼리를 3초에서 4ms로 750배의 성능을 향상시켰다.** 그 후 코드를 빌드하여 테스트 서버에 배포한 후 성능 측정을 진행했다.

![query-plan](/assets/img/2024-11-10-delete-scene-performance-1.png)

## 2차 성능 측정

1차 성능 측정과 동일하게 데이터 구성 후 API를 호출해봤다. 결과를 확인해보니 정상적으로 데이터가 삭제되며 880ms가 소요되는 것을 볼 수 있었다. 즉, **삭제 API 성능이 1분에서 880ms로 성능이 약 60배 개선되었다.**

![query-plan](/assets/img/2024-11-10-delete-scene-performance-2.png)

## 정리

영상 목록을 삭제할 때 1분 이상 소요됐으나 비동기와 인덱스를 적용함으로써 소요시간을 1초 이하로 줄여 60배 이상의 성능 개선을 할 수 있었다. 이번 버그 수정 작업을 통해 다음 두 가지를 깨달았다. 첫 번째로 API를 구현할 때 **동기로 처리할 것과 비동기로 처리할 것을 명확하게 나눈 후에 구현**하는 것이 중요하다는 것과 두 번째로 데이터를 삭제할 때 **제약 조건에 의해 쿼리가 느려질 수 있다**는 것이다. 앞으로 이러한 내용을 주의해서 API를 구현하도록 하자.