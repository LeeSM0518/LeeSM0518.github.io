# 일정 추가 기능 구현 계획

## 개요
목표(Goal)와 관련된 일정(Schedule)을 추가하는 기능을 구현하여 사용자가 목표 달성을 위한 세부 일정을 관리할 수 있도록 한다.

## 일정 데이터 구조
- **제목**: 일정의 제목 (String)
- **내용**: 일정에 대한 상세 설명 (String, nullable)
- **상태**: READY, COMPLETED (enum)
- **시작 날짜**: 일정 시작일 (Instant)
- **종료 날짜**: 일정 종료일 (Instant)
- **관련 목표 식별자**: 연결된 목표의 UUID

## 기존 Goal 모듈 구조 분석
현재 Goal 모듈은 다음과 같이 구성되어 있음:
- **Domain**: Goal.kt, GoalStatus.kt
- **Entity**: GoalEntity.kt (Spring Data R2DBC 사용)
- **DTO**: CreateGoalRequest.kt, GetGoals.kt, GoalResponse.kt
- **Repository**: GoalRepository.kt
- **Service**: GoalService.kt
- **Controller**: GoalController.kt, GoalControllerDocs.kt

## 구현 작업 계획

### 1. 도메인 레이어 구현 (Domain Layer)
1. **ScheduleStatus.kt** 생성
   - READY, COMPLETED 상태를 가진 enum class 구현

2. **Schedule.kt** 생성
   - 일정 도메인 모델 정의
   - ScheduleEntity로부터 Schedule을 생성하는 companion function 구현

### 2. 데이터 레이어 구현 (Data Layer)
1. **ScheduleEntity.kt** 생성
   - Spring Data R2DBC를 사용한 엔티티 정의
   - `schedules` 테이블과 매핑
   - GoalEntity와 외래키 관계 설정 (goalId)
   - Persistable<UUID> 구현

2. **ScheduleRepository.kt** 생성
   - R2dbcRepository 상속
   - 목표별 일정 조회 메서드 추가
   - 상태별 일정 조회 메서드 추가

### 3. DTO 레이어 구현 (DTO Layer)
1. **CreateScheduleRequest.kt** 생성
   - 클라이언트로부터 받을 일정 생성 요청 DTO

2. **CreateScheduleRequestDto.kt** 생성
   - 서비스 레이어에서 사용할 내부 DTO
   - userId 포함한 전체 정보

3. **ScheduleResponse.kt** 생성
   - 클라이언트에게 반환할 일정 응답 DTO

4. **GetSchedulesRequest.kt** 생성
   - 일정 목록 조회 요청 DTO
   - 목표 ID, 상태 필터링 옵션 포함

5. **GetSchedulesRequestDto.kt** 생성
   - 서비스 레이어용 조회 요청 DTO

### 4. 서비스 레이어 구현 (Service Layer)
1. **ScheduleService.kt** 생성
   - 일정 생성 로직 구현
   - 일정 조회 로직 구현 (목표별, 상태별)
   - 일정 수정 로직 구현
   - 일정 삭제 로직 구현
   - 목표 존재 여부 검증 로직

### 5. 컨트롤러 레이어 구현 (Controller Layer)
1. **ScheduleControllerDocs.kt** 생성
   - Swagger 문서화를 위한 인터페이스 정의

2. **ScheduleController.kt** 생성
   - REST API 엔드포인트 구현
   - POST /api/v1/schedules (일정 생성)
   - GET /api/v1/schedules (일정 목록 조회)
   - PUT /api/v1/schedules/{id} (일정 수정)
   - DELETE /api/v1/schedules/{id} (일정 삭제)

### 6. 데이터베이스 스키마 구현
1. **schedules 테이블 생성**
   ```sql
   CREATE TABLE schedules (
     schedule_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     goal_id UUID NOT NULL REFERENCES goals(goal_id),
     user_id UUID NOT NULL,
     title VARCHAR(255) NOT NULL,
     description TEXT,
     status VARCHAR(20) NOT NULL DEFAULT 'READY',
     start_date TIMESTAMPTZ NOT NULL,
     end_date TIMESTAMPTZ NOT NULL,
     created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
     updated_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
     deleted_at TIMESTAMPTZ
   );
   ```

2. **인덱스 생성**
   - goal_id에 대한 인덱스
   - user_id에 대한 인덱스
   - status에 대한 인덱스

### 7. 테스트 코드 작성
1. **단위 테스트**
   - ScheduleService 테스트
   - ScheduleController 테스트
   - ScheduleRepository 테스트

2. **통합 테스트**
   - API 엔드포인트 통합 테스트
   - 데이터베이스 연동 테스트

### 8. 추가 고려사항
1. **유효성 검증**
   - 시작 날짜가 종료 날짜보다 이전인지 검증
   - 목표가 존재하는지 검증
   - 사용자 권한 검증 (자신의 목표에만 일정 추가 가능)

2. **비즈니스 로직**
   - 삭제된 목표의 일정 처리 방안
   - 일정 상태 변경 규칙
   - 목표와 일정 간의 일관성 유지

3. **성능 최적화**
   - 목표별 일정 조회 시 페이징 처리
   - 적절한 인덱스 설계
   - N+1 쿼리 방지

## 구현 순서
1. 도메인 및 엔티티 레이어 (기본 구조)
2. 레포지토리 레이어 (데이터 접근)
3. DTO 레이어 (데이터 전송 객체)
4. 서비스 레이어 (비즈니스 로직)
5. 컨트롤러 레이어 (API 엔드포인트)
6. 데이터베이스 스키마 및 마이그레이션
7. 테스트 코드 작성
8. 문서화 및 검증

이 계획을 통해 기존 Goal 모듈의 구조와 일관성을 유지하면서 Schedule 기능을 효과적으로 추가할 수 있습니다.